% Inverse Kinematik für allgemeinen Roboter
% % Variante 3:
% * Translation mit Vektor 0-E statt A-B
% * Absolute Rotation ausgedrückt bspw. in XYZ-Euler-Winkeln
%   (statt XYZ wird die Konvention aus `phiconv_W_E` genommen)
% * Rotationsfehler mit Orientierungsfehler ZYX-Rotation um festes KS
%   (Linksmultiplikation)
% Numerische Berechnung mit Inverser Jacobi-Matrix der inversen Kinematik.
% Dadurch Berechnung aller Gelenkwinkel aller Beine auf einmal
% 
% Eingabe:
% xE_soll [6x1]
%   Endeffektorpose des Roboters bezüglich des Basis-KS (Soll)
% q0 [Nx1]
%   Startkonfiguration: Alle Gelenkwinkel aller serieller Beinketten der PKM
% s
%   Struktur mit Eingabedaten. Felder, siehe Quelltext.
% 
% Ausgabe:
% q [Nx1]
%   Alle Gelenkwinkel aller serieller Beinketten der PKM als Lösung der IK
% Phi
%   Kinematische Zwangsbedingungen für die Lösung. Bei korrekter Berechnung
%   muss dieser Wert Null sein.
% Tc_stack_PKM 
%   Gestapelte Transformationsmatrizen der PKM. Im Basis-KS.
%   Entspricht mit Abwandlung der Anordnung wie in fkine:
%   * PKM-Basis
%   * Für jede Beinkette: Basis und alle bewegten Körper-KS. Ohne
%     virtuelles EE-KS
%   * Kein Plattform-KS
% Stats
%   Struktur mit Detail-Ergebnissen für den Verlauf der Berechnung
% 
% Quelle:
% [SchapplerTapOrt2019] Schappler, M. et al.: Modeling Parallel Robot Kine-
% matics for 3T2R and 3T3R Tasks using Reciprocal Sets of Euler Angles (2019)
% [NakamuraHan1986] Y. Nakamura, H. Hanafusa: Inverse Kinematic Solutions 
% With Singularity Robustness for Robot Manipulator Control, 1986
% [CorkeIK] Peter Corke, Robotics Toolbox, ikine.m

% Diese Datei ist identisch mit: ParRob/invkin3.m
% Generierung einer kompilierbaren Matlab-Funktion aus Vorlage.


% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2018-07/2019-06
% (C) Institut für Mechatronische Systeme, Leibniz Universität Hannover

function [q, Phi, Tc_stack_PKM, Stats] = %PN%_invkin3(xE_soll, q0, s)

%% Coder Information
%#codegen
%$cgargs {zeros(6,1),zeros(%NJ%,1), struct(
%$cgargs       'I_EE_Task', true(1,6),
%$cgargs           'sigma', zeros(%NJ%,1),
%$cgargs               'K', zeros(%NJ%,1),
%$cgargs              'Kn', zeros(%NJ%,1),
%$cgargs              'wn', zeros(4,1),
%$cgargs      'maxstep_ns', 0,
%$cgargs       'normalize', true,
%$cgargs      'condlimDLS', 60,
%$cgargs      'lambda_min', 2e-4,
%$cgargs           'n_min', 0,
%$cgargs           'n_max', 1000,
%$cgargs        'rng_seed', NaN,
%$cgargs       'scale_lim', 1,
%$cgargs        'Phit_tol', 1e-8,
%$cgargs        'Phir_tol', 1e-8,
%$cgargs      'maxrelstep', 0.1,
%$cgargs   'maxrelstep_ns', 0.005,
%$cgargs'finish_in_limits', false,
%$cgargs     'retry_limit', 100,
%$cgargs      'I_constr_t', ones(1,%NLEG%*6/2),
%$cgargs      'I_constr_r', ones(1,%NLEG%*6/2),
%$cgargs  'I_constr_t_red', coder.newtype('double',[1,inf]),
%$cgargs  'I_constr_r_red', coder.newtype('double',[1,inf]),
%$cgargs    'I_constr_red', coder.newtype('double',[1,inf]),
%$cgargs            'I_qa', false(%NJ%,1),
%$cgargs       'r_P_B_all', zeros(3,%NLEG%),
%$cgargs     'phi_P_B_all', zeros(3,%NLEG%),
%$cgargs     'phiconv_W_E', uint8(2),
%$cgargs           'T_P_E', zeros(4,4),
%$cgargs   'Leg_I_EE_Task', true(%NLEG%,6),
%$cgargs    'Leg_pkin_gen', zeros(%NLEG%,%NKP%),
%$cgargs   'Leg_T_N_E_vec', zeros(6,%NLEG%),
%$cgargs   'Leg_T_0_W_vec', zeros(6,%NLEG%),
%$cgargs     'Leg_phi_W_0', zeros(3,%NLEG%),
%$cgargs 'Leg_phiconv_W_0', uint8(zeros(%NLEG%,1)),
%$cgargs        'Leg_qlim', zeros(6,2*%NLEG%))}

%% Initialisierung
Rob_I_EE = %I_EE%;
I1J_LEG = %I1J_LEG%;
I2J_LEG = %I2J_LEG%;
Leg_I_EElink = %Leg_I_EElink%;
Leg_NQJ = %Leg_NQJ%;
NJ = %NJ%;
NL = %NL%;
NLEG = %NLEG%;

%% Definitionen
sigma_PKM = s.sigma;
% Struktur für %PN%_constr4grad_q
s_q = struct(...
          'I_constr_t_red', s.I_constr_t_red,...
          'I_constr_r_red', s.I_constr_r_red,...
            'I_constr_t', s.I_constr_t,...
            'I_constr_r', s.I_constr_r,...
           'Leg_I_EE_Task', s.Leg_I_EE_Task,...
            'Leg_pkin_gen', s.Leg_pkin_gen,...
           'Leg_T_N_E_vec', s.Leg_T_N_E_vec,...
             'Leg_phi_W_0', s.Leg_phi_W_0,...
         'Leg_phiconv_W_0', s.Leg_phiconv_W_0);
 % Struktur für %PN%_constr4grad_x
 s_x = struct(...
          'I_constr_t_red', s.I_constr_t_red,...
          'I_constr_r_red', s.I_constr_r_red,...
              'I_constr_t', s.I_constr_t,...
              'I_constr_r', s.I_constr_r,...
               'r_P_B_all', s.r_P_B_all,...
             'phiconv_W_E', s.phiconv_W_E,...
                   'T_P_E', s.T_P_E,...
           'Leg_I_EE_Task', s.Leg_I_EE_Task);
% Struktur für %PN%_constr3grad_q
s_cst3_q = struct(...
               'I_EE_Task', s.I_EE_Task,...
               'r_P_B_all', s.r_P_B_all,...
             'phi_P_B_all', s.phi_P_B_all,...
             'phiconv_W_E', s.phiconv_W_E,...
                   'T_P_E', s.T_P_E,...
            'Leg_pkin_gen', s.Leg_pkin_gen,...
           'Leg_T_N_E_vec', s.Leg_T_N_E_vec,...
           'Leg_I_EE_Task', s.Leg_I_EE_Task,...
             'Leg_phi_W_0', s.Leg_phi_W_0,...
         'Leg_phiconv_W_0', s.Leg_phiconv_W_0);
% Struktur für %PN%_constr3
s_cst3 = struct(...
          'I_constr_t_red', s.I_constr_t_red,...
          'I_constr_r_red', s.I_constr_r_red,...
               'r_P_B_all', s.r_P_B_all,...
             'phi_P_B_all', s.phi_P_B_all,...
                   'T_P_E', s.T_P_E,...        
             'phiconv_W_E', s.phiconv_W_E,...
           'Leg_I_EE_Task', s.Leg_I_EE_Task,...
            'Leg_pkin_gen', s.Leg_pkin_gen,...
           'Leg_T_N_E_vec', s.Leg_T_N_E_vec,...
           'Leg_T_0_W_vec', s.Leg_T_0_W_vec,...
             'Leg_phi_W_0', s.Leg_phi_W_0,...
         'Leg_phiconv_W_0', s.Leg_phiconv_W_0);
% Struktur für %PN%_constr3grad_x
s_3x = struct(...
            'I_constr_red', s.I_constr_red,...
             'phi_P_B_all', s.phi_P_B_all,...
                   'T_P_E', s.T_P_E,...
             'phiconv_W_E', s.phiconv_W_E,...
            'Leg_pkin_gen', s.Leg_pkin_gen,...
           'Leg_T_N_E_vec', s.Leg_T_N_E_vec,...
           'Leg_T_0_W_vec', s.Leg_T_0_W_vec,...
           'Leg_I_EE_Task', s.Leg_I_EE_Task,...
             'Leg_phi_W_0', s.Leg_phi_W_0,...
         'Leg_phiconv_W_0', s.Leg_phiconv_W_0);
% Variablen aus Einstellungsstruktur holen
K = s.K; 
Kn = s.Kn; 
n_min = s.n_min;
n_max = s.n_max;
wn = s.wn;
condlimDLS = s.condlimDLS;
lambda_min = s.lambda_min;
scale_lim = s.scale_lim;
Phit_tol = s.Phit_tol;
Phir_tol = s.Phir_tol;
retry_limit = s.retry_limit;
maxrelstep = s.maxrelstep;
maxrelstep_ns = s.maxrelstep_ns;
maxstep_ns = s.maxstep_ns;
finish_in_limits = s.finish_in_limits;
break_when_in_limits = false;
success = false;

nsoptim = false;
if sum(Rob_I_EE) > sum(s.I_EE_Task)
  % Nullraumoptimierung nur möglich, falls FG da sind. TODO: Das
  % berücksichtigt noch nicht den Fall von 3T3R-PKM in 3T0R-Aufgaben.
  if any(wn ~= 0)
    nsoptim = true;
  end
else
  % Keine zusätzlichen Optimierungskriterien
  finish_in_limits = false; % Alle Nullraumbewegungen nicht möglich
end
% Prüfe, ob der Fall von 1FG-Aufgabenredundanz vorliegt.
if sum(Rob_I_EE) - sum(s.I_EE_Task) == 1 && ~s.I_EE_Task(end)
  taskred_rotsym = true;
else
  taskred_rotsym = true;
end

qlim = NaN(NJ,2);
J1 = 1;
for i = 1:NLEG
  J2 = J1+Leg_NQJ(i)-1;
  qlim(J1:J2,:) = s.Leg_qlim(1:Leg_NQJ(i),(1+2*(i-1)):(2+2*(i-1)));
  J1 = J2+1;
end
qmin = qlim(:,1);
qmax = qlim(:,2);
limits_set = false;
if all(~isnan(qlim(:)))
  limits_set = true;
else
  % Grenzen sind nicht wirksam
  qmin = -Inf(NJ,1);
  qmax =  Inf(NJ,1);
  retry_limit = 0; % keine zufällige Neubestimmung möglich.
  finish_in_limits = false;
end
% Grenzen für die Neubestimmung der Anfangswerte (falls unendl. vorkommt).
% Annahme: Betrifft nur Drehgelenke. Dort dann zwischen -pi und pi.
% Die Variable qmin/qmax wird für Nebenbedingungen benutzt.
qmin_norm = qmin; qmax_norm = qmax;
qmin_norm(isinf(qmin)) = sign(qmin_norm(isinf(qmin)))*(pi);
qmax_norm(isinf(qmax)) = sign(qmax_norm(isinf(qmax)))*(pi);
delta_qlim = NaN(NJ,1);
delta_qlim = qmax - qmin;
I_constr_t_red = s.I_constr_t_red;
I_constr_r_red = s.I_constr_r_red;
% Variablen für Dämpfung der Inkremente
delta_q_alt = zeros(NJ,1); % Altwert für Tiefpassfilter
delta_q_N_alt = zeros(NJ,1); % Altwert für Nullraum-Tiefpassfilter
damping_active = false; % Standardmäßig noch nicht aktiviert
% Zuweisung notwendig für mex (rr-Schleife nicht automatisch erkannt)
q1 = q0;
rownum_Phi_red = sum(s.Leg_I_EE_Task(1,4:6))+... % für Führungskette
  sum(sum(s.Leg_I_EE_Task(2:end,4:6))); % für Folgeketten
Phi = NaN(rownum_Phi_red,1);
Phi_voll = NaN(NLEG*6,1);
Phi4_q_voll = NaN(NLEG*6,NJ);
Phi4_x_voll = NaN(NLEG*6,6);
q2 = q0;
N = NaN(NJ,NJ); % Nullraum-Projektor
% Gradient von Nebenbedingung 3 und 4
h3dq = zeros(1,NJ); h4dq = zeros(1,NJ);
h = zeros(4,1); h_alt = inf(4,1); % Speicherung der Werte der Nebenbedingungen

% Zählung in Rob.NL: Starrkörper der Beinketten, Gestell und Plattform. 
% Hier werden nur die Basis-KS der Beinketten und alle bewegten Körper-KS
% der Beine angegeben.
Tc_stack_PKM = NaN((NL-1+NLEG)*3,4); % siehe fkine_legs; dort aber leicht anders
% Basis-KS. Trägt keine Information. Dient nur zum einfacheren Zugriff auf
% die Variable und zur Angleichung an Darstellung im Welt-KS.
Tc_stack_PKM(1:3,1:4) = eye(3,4); % Basis-KS im Basis-KS.
out3_ind1 = 3; % Zeilenzähler für obige Variable (drei Zeilen stehen schon)
rejcount = 0; % Zähler für Zurückweisung des Iterationsschrittes, siehe [CorkeIK]
condJpkm = NaN;
if nargout == 4
  Stats = struct('Q', NaN(1+n_max, NJ), 'PHI', NaN(1+n_max, 6*NLEG), 'iter', n_max, ...
    'retry_number', retry_limit, 'condJ', NaN(1+n_max,1), 'lambda', ...
    NaN(n_max,2), 'rejcount', NaN(n_max,1), 'h', NaN(1+n_max,1+4));
end
%% Iterative Berechnung der inversen Kinematik
for rr = 0:retry_limit % Schleife über Neu-Anfänge der Berechnung
  q1 = q0;
  % Grad der Nicht-Erfüllung der Zwangsbedingungen (Fehler)
  [Phi, Phi_voll] = %PN%_constr3(q1, xE_soll, s_cst3);
  if nargout == 4
    Stats.PHI(1,:) = Phi_voll;
    Stats.Q(1,:) = q1;
  end
  lambda_mult = lambda_min; % Zurücksetzen der Dämpfung
  lambda = 0.0;
  rejcount = 0; % Zurücksetzen des Zählers für Fehlversuche
  for jj = 1:n_max
    % Gesamt-Jacobi bilden (reduziert um nicht betrachtete EE-Koordinaten)
    Jik=%PN%_constr3grad_q(q1, xE_soll, s_cst3_q);
    %% Nullstellensuche für Positions- und Orientierungsfehler
    condJ = cond(Jik);
    % (Optimierung der Aufgabe)
    % Benutze das Damped Least Squares Verfahren je nach Konditionszahl.
    % Bei Redundanz immer benutzen, nicht nur, falls Nullraumprojektion erfolglos.
    if condJ > condlimDLS% && (~nsoptim || nsoptim && rejcount > 0)
      % Pseudo-Inverse mit Dämpfung:
      % Passe die Dämpfung lambda im DLS-Verfahren an. Wähle die Kon-
      % ditionszahl als Kriterium, da z.B. Grenzen für Singulärwerte
      % und Manipulierbarkeit nicht bekannt sind.
      % Skalierung zwischen 0 (z.B. Grenzfall cond=60) und 1 (komplett singulär).
      % Nehme einen Mindestwert für die Dämpfung und einen sich bei Stagnation
      % erhöhenden Aufschlag. Mit Aufschlag wird immer lambda_min benutzt.
      lambda = (-1+2*2/pi*atan(condJ/condlimDLS))*(lambda_min+lambda_mult)/2;
      % [NakamuraHan1986], Gl. 22. Kleinere Dimension bei Redundanz als andere pinv.
      delta_q_T = ((Jik')/(Jik*Jik' + lambda*eye(length(Phi))))*(-Phi);
    else
      % Normale (Pseudo-)Invertierung der Jacobi-Matrix der seriellen Kette
      delta_q_T = Jik \ (-Phi);
      lambda = 0.0;
      lambda_mult = lambda_min; % Zurücksetzen. Alles (wieder) i.O.
    end
    %% Optimierung der Nebenbedingungen (Nullraum)
    delta_q_N = zeros(size(delta_q_T));
    if nsoptim && ... % Nullraum muss vorhanden sein und Kriterien gesetzt
        jj < n_max-10 && ...% die letzten Iterationen sind zum Ausgleich des Positionsfehlers (ohne Nullraum)
        rejcount == 0 %% falls vorherige Iterationen erfolglos, keine Nullraumbewegung. Annahme: Schädlich für Konvergenz
      % Berechne Gradienten der zusätzlichen Optimierungskriterien
      v = zeros(NJ, 1);
      if wn(1) ~= 0
        [h(1), h1dq] = invkin_optimcrit_limits1(q1, qlim);
        v = v - wn(1)*h1dq'; % [SchapplerTapOrt2019], Gl. (44)
      end
      if wn(2) ~= 0
        [h(2), h2dq] = invkin_optimcrit_limits2(q1, qlim);
        % Setze den Gradienten auf eine sehr große Zahl, wenn eine Grenze
        % überschritten wird. Sonst auch Abbruch bei unendlich.
        % Die Nullraumbewegung wird später sowieso reduziert.
        h2dq(q1>=qlim(:,2)) = 1e10; h2dq(q1<=qlim(:,1)) = -1e10;
        v = v - wn(2)*h2dq'; % [SchapplerTapOrt2019], Gl. (45)
      end
      if wn(3) ~= 0 || wn(4) ~= 0 % Singularitäts-Kennzahl aus Konditionszahl
        Jinv = NaN(NJ, 6);
        % Bestimme Ist-Lage der Plattform (bezogen auf erste Beinkette).
        % Benutze dies für die Berechnung der PKM-Jacobi. Nicht aussage-
        % kräftig, wenn Zwangsbedingungen grob verletzt sind. Dafür wird
        % die Rotation korrekt berücksichtigt.
        xE_1 = xE_soll + [zeros(5,1); Phi_voll(4)];
        if wn(4) || taskred_rotsym && all(abs(Phi)<1e-3) % Bestimme PKM-Jacobi für Iterationsschritt
          % Benutze einfache Jacobi-Matrix und nicht die constr3grad-
          % Funktionen. Jinv ist zwischen beiden nur identisch, wenn Phi
          % exakt Null ist.
          [~, Phi4_x_voll] = %PN%_constr4grad_x(xE_1,s_x);
          [~, Phi4_q_voll] = %PN%_constr4grad_q(q1,s_q);
          Jinv = -Phi4_q_voll\Phi4_x_voll; % bezogen auf 3T3R
          condJpkm = cond(Jinv(s.I_qa,Rob_I_EE)); % bezogen auf Antriebe (nicht: Passive Gelenke)
          h(4) = condJpkm;
        end
        % Zwei verschiedene Arten zur Berechnung der Nullraumbewegung, je
        % nachdem, ob die Beinketten schon geschlossen sind, oder nicht.
        if all(abs(Phi)<1e-3) && taskred_rotsym
          % Bestimme Nullraumbewegung durch Differenzenquotient für die 
          % redundante Koordinate. Dadurch nur eine neue Funktions- 
          % auswertung
          xD_test_3T3R = [zeros(5,1);1e-8];
          xD_test = xD_test_3T3R; % Hier werden für 2T1R nicht die Koordinaten reduziert
          qD_test = Jinv * xD_test;
          if wn(3)
            % Einfacher Differenzenquotient für Kond. der IK-Jacobi-Matrix
            Phi_q_test = %PN%_constr3grad_q(q1+qD_test, xE_soll, s_cst3_q);
            condJ_test = cond(Phi_q_test);
            h3dq = (condJ_test-condJ)./qD_test';
          end
          if wn(4)
            % Benutze Formel für Differential des Matrix-Produkts mit 
            % Matrix-Invertierung zur Bildung des PKM-Jacobi-Inkrements
            [~,Phi4_x_voll_test] = %PN%_constr4grad_x(xE_1+xD_test,s_x);
            [~,Phi4_q_voll_test] = %PN%_constr4grad_q(q1+qD_test,s_q);
            Phi4D_x_voll = Phi4_x_voll_test-Phi4_x_voll;
            Phi4D_q_voll = Phi4_q_voll_test-Phi4_q_voll;
            Jinv_test = Jinv + ...
              Phi4_q_voll\Phi4D_q_voll/Phi4_q_voll*Phi4_x_voll + ...
              -Phi4_q_voll\Phi4D_x_voll;
            h4_test = cond(Jinv_test(s.I_qa,Rob_I_EE));
            h4dq = (h4_test-h(4))./qD_test';
          end
        else
          % Bestimme Nullraumbewegung durch Differenzenquotient für jede
          % Gelenkkoordinate.
          if wn(3) % Kennzahl bezogen auf Jacobi-Matrix der inversen Kinematik
            for kkk = 1:NJ
              q_test = q1; % ausgehend von aktueller Konfiguration
              q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
              Jik_kkk=%PN%_constr3grad_q(q_test, xE_soll, s_cst3_q); % Berechnung identisch mit oben
              condJik_kkk = cond(Jik_kkk);
              % Differenzenquotient aus Log-Kond. scheint bei hohen Konditions-
              % zahlen numerisch etwas besser zu dämpfen (sonst dort sofort
              % maximal große Sprünge der Gelenkwinkel). Dafür Gradient dort gering.
              h3dq(kkk) = (condJik_kkk-condJ)/1e-6;
            end
          end
          if wn(4) % bezogen auf PKM-Jacobi
            for kkk = 1:NJ
              q_test = q1; % ausgehend von aktueller Konfiguration
              q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
              [~, Phi4_q_voll_kkk] = %PN%_constr4grad_q(q_test,s_q);
              Jinv_kkk = -Phi4_q_voll_kkk\Phi4_x_voll;
              condJpkm_kkk = cond(Jinv_kkk(s.I_qa,Rob_I_EE));
              h4dq(kkk) = (condJpkm_kkk-condJpkm)/1e-6;
            end
          end
        end
        if wn(3), v = v - wn(3)*h3dq'; end
        if wn(4), v = v - wn(4)*h4dq'; end
        h(3) = condJ;
      end
      % [SchapplerTapOrt2019], Gl. (43)
      N = (eye(NJ) - pinv(Jik)* Jik);
      delta_q_N(:) = N * v;
    end

    % Reduziere Schrittweite auf einen absoluten Wert. Annahme: Newton-
    % Raphson-Verfahren basiert auf Linearisierung. Kleinwinkelnäherung
    % wird verlassen, wenn Gelenkwinkel mehr als 3° drehen. Hier keine
    % Betrachtung der Summe, wie bei seriellen Robotern.
    % Führe das getrennt für delta_q_T und delta_q_N durch, damit die 
    % Nullraumbewegung nicht die Aufgabenbewegung dominieren kann.
    delta_q_T = K.*delta_q_T;
    delta_q_N = Kn.*delta_q_N;
    abs_delta_qTrev = abs(delta_q_T(sigma_PKM==0)); % nur Drehgelenke
    if any(abs_delta_qTrev > 0.5) % 0.5rad=30°
      % Reduziere das Gelenk-Inkrement so, dass das betragsgrößte
      % Winkelinkrement danach 30° hat.
      delta_q_T = delta_q_T .* 0.5/max(abs_delta_qTrev);
    end
    abs_delta_qNrev = abs(delta_q_N(sigma_PKM==0)); % nur Drehgelenke
    if any(abs_delta_qNrev > 0.05*(1-jj/n_max)) % 0.05rad=3°
      % Reduziere das Gelenk-Inkrement so, dass das betragsgrößte
      % Winkelinkrement danach 3° hat.
      % Verkleinere die Schritte mit fortlaufenden Iterationen, um even-
      % tuellen Oszillationen auszugleichen.
      delta_q_N = delta_q_N .* 0.05*(1-jj/n_max)/max(abs_delta_qNrev);
    end
    
    % Reduziere die einzelnen Komponenten bezüglich der Winkelgrenzen
    % Bei nur gemeinsamer Reduzierung kann die Nullraumbewegung zu groß
    % werden; Dokumentation siehe unten
    if limits_set && ~isnan(maxrelstep)
      abs_delta_q_T_rel = abs(delta_q_T ./ delta_qlim .* K);
      if any(abs_delta_q_T_rel > maxrelstep)
        delta_q_T = delta_q_T .* maxrelstep / max(abs_delta_q_T_rel);
      end
    end
    if nsoptim && limits_set && ~isnan(maxrelstep_ns)
      abs_delta_q_N_rel = abs(delta_q_N ./ delta_qlim .* Kn);
      if any(abs_delta_q_N_rel > maxrelstep_ns)
        delta_q_N = delta_q_N .* maxrelstep_ns / max(abs_delta_q_N_rel);
      end
    end
    % Dämpfung der Nullraumbewegung. Verlangsamt die Konvergenz, reduziert
    % dafür Schwingungen zwischen delta_q_T und delta_q_N, die durch keine
    % der anderen Stabilisierungsmaßnahmen erfasst werden. Nur machen, wenn
    % auch Bewegung im Nullraum (nicht wenn q_N deaktiviert wurde)
    if nsoptim && damping_active && any(delta_q_N)
      % Korrigiere den Altwert, da bezogen auf andere Gelenkkonfig.
      delta_q_N_alt_N = N*delta_q_N_alt;
      % Benutze diskretes PT1-Filter mit T=2 (Schritte der IK) und K=1
      delta_q_N = delta_q_N_alt_N + 1/(1+2)*(1*delta_q_N-delta_q_N_alt_N);
      delta_q_N_alt = delta_q_N;
    end
    
    % Inkrement der Gelenkwinkel; [SchapplerTapOrt2019], Gl. (43)
    % Verstärkungsfaktoren K und Kn oben bereits angewendet.
    delta_q = delta_q_T + delta_q_N;
    
    % Reduziere Schrittweite (qT+qN gemeinsam) auf einen Maximalwert
    % bezogen auf Winkelgrenzen (bzw. auf die mögliche Spannweite)
    if limits_set && ~isnan(maxrelstep)
      % Bestimme Inkrement relativ zur Spannbreite der Grenzen
      abs_delta_q_rel = abs(delta_q ./ delta_qlim);
      if any(abs_delta_q_rel > maxrelstep)
        % Ein Element hat ein zu großes Inkrement. Normiere den
        % Inkrement-Vektor damit
        delta_q = delta_q .* maxrelstep / max(abs_delta_q_rel);
      end
    end
    % Zusätzlicher Dämpfungsterm (gegen Oszillationen insbesondere der
    % Nullraumbewegung). Aktiviere, sobald Oszillationen erkannt werden
    if damping_active
      % Benutze diskretes PT1-Filter mit T=2 (Schritte der IK) und K=1
      % Hier deaktiviert. Filtere nur Nullraumbewegung oben.
      % delta_q = delta_q_alt + 1/(1+2)*(1*delta_q-delta_q_alt);
    elseif all(sign(delta_q) == -sign(delta_q_alt))
      damping_active = true; % ab jetzt aktiviert lassen.
    end
    delta_q_alt = delta_q;
    
    % Gelenkwinkel-Schritt anwenden
    q2 = q1 + delta_q;
    
    % Prüfe, ob die Gelenkwinkel ihre Grenzen überschreiten und reduziere
    % die Schrittweite, falls das der Fall ist; [SchapplerTapOrt2019], Gl. (47)
    if scale_lim
      delta_ul_rel = (qmax - q2)./(qmax-q1); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qmin + q2)./(q1-qmin); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        % Berechne die prozentual stärkste Überschreitung
        % und nutze diese als Skalierung für die Winkeländerung
        % Reduziere die Winkeländerung so, dass die gröte Überschreitung auf
        % das Erreichen der Grenzen reduziert wird.
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qmax(I_max)-q1(I_max))./(delta_q(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qmin(I_min)-q1(I_min))./(delta_q(I_min));
        end
        % Mit `scale` werden die Grenzen direkt für ein Gelenk erreicht.
        % Durch `scale_lim` wird dieses Erreichen weiter nach "innen" gezogen
        delta_q = scale_lim*scale*delta_q;
        q2 = q1 + delta_q;
      end
    end

    if any(isnan(q2)) || any(isinf(q2))
      if nargout == 4
        Stats.iter = jj;
      end
      break; % ab hier kann das Ergebnis nicht mehr besser werden wegen NaN/Inf
    end

    % Fehlermaß für aktuelle Iteration (wird auch in nächster Iteration benutzt)
    [Phi_neu, Phi_voll] = %PN%_constr3(q2, xE_soll, s_cst3);
    % Prüfe, ob Wert klein genug ist. Bei kleinen Zahlenwerten, ist
    % numerisch teilweise keine Verbesserung möglich.
    Phi_iO = all(abs(Phi_neu(I_constr_t_red)) < Phit_tol) && ...
             all(abs(Phi_neu(I_constr_r_red)) < Phir_tol);
    if Phi_iO && any(delta_q_N) && sum(wn.*h)>=sum(wn.*h_alt)
      % Prüfe, ob sich die Nebenbedingungen überhaupt noch verbessern. Wenn
      % nicht, kann auch abgebrochen werden. Variable delta_q_N dient zur
      % Ablaufsteuerung für folgende Abfragen (nicht für Ergebnis selbst).
      delta_q_N(:) = 0;
    end
    % Prüfe, ob Schritt erfolgreich war (an dieser Stelle, da der 
    % Altwert von Phi noch verfügbar ist). Siehe [CorkeIK].
    Delta_Phi = norm(Phi_neu) - norm(Phi); % "neu" - "alt";
    if any(delta_q_N) && sum(wn.*h)>=sum(wn.*h_alt) && Delta_Phi > 0
      % Zusätzliches Optimierungskriterium hat sich verschlechtert und
      % gleichzeitig auch die IK-Konvergenz. Das deutet auf eine
      % Konvergenz mit Oszillationen hin. Reduziere den Betrag der
      % Nullraumbewegung. Annahme: Bewegung so groß, dass keine
      % Linearisierungsfehler (außerhalb des Nullraums) zu groß.
      Kn = Kn*0.8;
    end
    if Phi_iO || Delta_Phi < 0 ... % Verbesserung des Residuums
        || any(delta_q_N) && all(abs(Phi_neu)<1e-3) && any(delta_q) % Bei Nullraumbewegung auch Verschlechterung möglich, wenn noch im "guten" Bereich
      if condJ>1e4 && Delta_Phi > -Phit_tol % Singularität mit Mini-Schritten
        % Erhöhe Dämpfung um von Singularität wegzukommen. Falls das nicht
        % funktioniert, führt das immerhin zu einem relativ frühen Abbruch,
        % da lambda gegen unendlich geht und dann sich Phi nicht mehr mit
        % Minimal-Schritten numerisch verbessert.
        lambda_mult = lambda_mult*2;
      else
        % Erfolgreich. Verringere lambda bis auf Minimalwert.
        lambda_mult = max(lambda_mult/2, lambda_min); % Singularität überwunden
      end
      % Behalte Ergebnis der Iteration für weitere Iterationen.
      q1 = q2;
      h_alt = h;
      % Behalte Wert für Phi nur in diesem Fall. Dadurch wird auch die Verbesserung
      % gegenüber der Iteration messbar, bei der zuletzt eine Verschlechterung eintrat.
      Phi = Phi_neu;
      rejcount = 0;
    else
      % Kein Erfolg. Erhöhe die Dämpfung. Mache den Schritt nicht.
      % Setzt voraus, dass die Konditionszahl so schlecht ist, dass
      % oben das DLS-Verfahren benutzt wird. Ansonsten Stillstand.
      lambda_mult = lambda_mult*2;
      rejcount = rejcount + 1;
      if condJ <= condlimDLS && ~nsoptim || ... % Keine Verbesserung der Konvergenz trotz guter Konditionszahl.
       rejcount > 50 % Stillstand zu lange trotz exponentieller Erhöhung von lambda.
        % Abbruch. Keine Verbesserung mit Algorithmus möglich.
        if nargout == 4
          Stats.iter = jj;
        end
        break;
      end
    end
    if nargout == 4
      Stats.Q(1+jj,:) = q1;
      Stats.PHI(1+jj,:) = Phi_voll;
      Stats.h(jj,:) = [sum(wn.*h),h'];
      Stats.condJ(jj) = condJ;
      Stats.lambda(jj,:) = [lambda, lambda_mult];
      Stats.rejcount(jj) = rejcount;
    end
    % Prüfe Abbruchbedingung für Einhaltung der Winkelgrenzen. Ist dies bei
    % "finish_in_limits" der Fall, muss die IK nur noch konvergiert sein.
    if break_when_in_limits && (all(q1 >= qlim(:,1)) && all(q1 <= qlim(:,2)))
      delta_q_N(:) = 0; % unvollständige Nullraumbewegung wird hiernach ignoriert.
      % hiernach dürfen die Grenzen nicht mehr verlassen werden (falls
      % noch weitere Iterationen gemacht werden)
      scale_lim = 0.7;
      % Reduziere die Nullraumbewegung ab hier ganz stark. Damit können die
      % Grenzen noch leicht nachkorrigiert werden, es dominiert aber die
      % Aufgabenbewegung.
      Kn = Kn*0.8;
    end
    % Abbruchbedingungen prüfen
    if jj >= n_min ... % Mindestzahl Iterationen erfüllt
     && Phi_iO && ... % Haupt-Bedingung ist erfüllt
     ( ~nsoptim || ...%  und keine Nebenoptimierung läuft
     nsoptim && all(abs(delta_q_N) < maxstep_ns) ) % oder die Nullraumoptimierung läuft noch
      success = true;
      if nargout == 4
        Stats.iter = jj; % muss hier zugewiesen werden (für mex)
      end
      if finish_in_limits && (any(q1 < qlim(:,1)) || any(q1 > qlim(:,2)))
        % Es soll eigentlich abgebrochen werden. Die Grenzen wurden aber 
        % nicht eingehalten. Mache noch mit dem Algorithmus weiter und 
        % optimiere nur noch die Grenzen (und nicht z.B. Konditionszahl)
        finish_in_limits = false; % Modus ist damit aktiviert
        nsoptim = true;
        wn = [0;1;0;0]; % Nutze nur die hyperbolische Funktion des Abstands
        % Mache diese Optimierung nicht mehr zu Ende, sondern höre auf, 
        % wenn die Grenzen erreicht sind.
        break_when_in_limits = true;
        continue
      end
      break;
    end
  end
  if success
    if nargout == 4
      Stats.retry_number = rr;
    end
    break;
  end
  % Beim vorherigen Durchlauf kein Erfolg. Generiere neue Anfangswerte
  if rr == 0 && ~isnan(s.rng_seed)
    rng(s.rng_seed); % Initialisiere Zufallszahlen, falls gewünscht
  end
  q0(:) = qmin_norm + rand(NJ,1).*(qmax_norm-qmin_norm); 
end
if nargout == 4 % Berechne Leistungsmerkmale für letzten Schritt
  if wn(1) ~= 0, h(1) = invkin_optimcrit_limits1(q1, qlim); end
  if wn(2) ~= 0, h(2) = invkin_optimcrit_limits2(q1, qlim); end
  Jik=%PN%_constr3grad_q(q1, xE_soll, s_cst3_q);
  h(3) = cond(Jik);
  if wn(4) % Bestimme PKM-Jacobi für Iterationsschritt
    % Benutze die einfachen Zwangsbedingungen, da vollständige FG.
    xE_1 = xE_soll + [zeros(5,1); Phi_voll(4)];
    [~, Phi4_x_voll] = %PN%_constr4grad_x(xE_1,s_x);
    [~, Phi4_q_voll] = %PN%_constr4grad_q(q1,s_q);
    Jinv = -Phi4_q_voll\Phi4_x_voll; % bezogen auf 3T3R
    h(4) = cond(Jinv(s.I_qa,Rob_I_EE));
  end
  Stats.h(Stats.iter+1,:) = [sum(wn.*h),h'];
  Stats.condJ(Stats.iter+1) = h(3);
end
q = q1;
if s.normalize
  q(sigma_PKM==0) = normalize_angle(q(sigma_PKM==0)); % nur Winkel normalisieren
end
if nargout >= 3
  for i = 1:NLEG
    q_i = q(I1J_LEG(i):I2J_LEG(i));
    % Aufruf der constr2-Funktion, da dort die Trafo-Matrix passend berechnet wird. Teilw. Dummy-Eingabe.
    [~, Tc_stack] = %SN%_constr2(q_i, eye(3,4), s.Leg_pkin_gen(i,:)', eye(4), s.phiconv_W_E, Leg_I_EElink(i),false);
    T_0_0i = invtr([eulxyz2r(s.Leg_T_0_W_vec(1:3,i)),s.Leg_T_0_W_vec(4:6,i);[0 0 0 1]]);
    % Umrechnung auf PKM-Basis-KS. Nehme nur die KS, die auch einem Körper
    % zugeordnet sind. In Tc_stack_0i bei hybriden Systemen teilw. mehr.
    Tc_stack_0 = NaN(3*(Leg_NQJ(i)+1),4);
    for kk = 1:Leg_NQJ(i)+1
      Tc_stack_k = Tc_stack((kk-1)*3+1:kk*3,1:4);
      T_0_kk = T_0_0i * [Tc_stack_k;[0 0 0 1]];
      Tc_stack_0((kk-1)*3+1:kk*3,1:4) = T_0_kk(1:3,:);
    end
    % Eintragen in Ergebnis-Variable
    Tc_stack_PKM(out3_ind1+(1:3*(Leg_NQJ(i)+1)),:) = Tc_stack_0;
    out3_ind1 = out3_ind1 + 3*(Leg_NQJ(i)+1);
  end
end
