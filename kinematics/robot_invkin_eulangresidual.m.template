% Inverse Kinematik basierend auf Euler-Winkel-Residuum für
% %RN%
%
% Eingabe:
% Tr0E_soll [3x4]
%   EE-Lage (Sollwert); homogene Transformationsmatrix ohne letzte Zeile
% q0
%   Anfangs-Gelenkwinkel für Algorithmus
% s
%   Struktur mit Eingabedaten. Felder, siehe Quelltext und SerRob/invkin2
%
% Ausgabe:
% q [%NJ% x 1]
%   Lösung der IK
% Phi
%   Restfehler mit der IK-Lösung
% Tc_stack [(%NJ%+1)*3 x 4]
%   Gestapelte homogene Transformationsmatrizen für q (jew. ohne 0001-Zeile)
%   (enthält alle Koordinatensysteme aus direkter Kinematik)
% Stats
%   Struktur mit Detail-Ergebnissen für den Verlauf der Berechnung. Felder:
%   .Q (n+1)x6: Gelenkkoordinaten für ersten Schritt und alle Iterationen
%   .PHI (n+1)x6: Residuum
%   .h (n+1x3): Leistungsmerkmale: (1) quadratischer Abstand von Grenzen,
%     (2) hyperbolischer Abstand von Grenzen, (3) Konditionszahl Jacobi
%   .condJ (n+1x1): Konditionszahl der IK-Jacobi-Matrix

% Quelle:
% [SchapplerTapOrt2019] Schappler, M. et al.: Resolution of Functional
% Redundancy for 3T2R Robot Tasks using Two Sets of Reciprocal Euler
% Angles, Proc. of the 15th IFToMM World Congress, 2019
% [1] Aufzeichnungen Schappler vom 3.8.2018
% [ChiaveriniSicEge1994] S. Chiaverini and B. Siciliano, O. Egeland: 
% Review of the damped least-squares inverse kinematics with experiments 
% on an industrial robot manipulator, 1994
% [NakamuraHan1986] Y. Nakamura, H. Hanafusa: Inverse Kinematic Solutions 
% With Singularity Robustness for Robot Manipulator Control, 1986
% [CorkeIK] Peter Corke, Robotics Toolbox, ikine.m

% %VERSIONINFO%
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2019-02
% (C) Institut für Mechatronische Systeme, Universität Hannover

function [q, Phi, Tc_stack, Stats] = %RN%_invkin_eulangresidual(Tr0E_soll, q0, s)

%% Coder Information
%#codegen
%$cgargs {zeros(3,4),zeros(%NQJ%,1),struct(
%$cgargs            'pkin', zeros(%NKP%,1),
%$cgargs          'sigmaJ', zeros(%NQJ%,1),
%$cgargs            'qlim', zeros(%NQJ%,2),
%$cgargs            'I_EE', true(1,6),
%$cgargs     'phiconv_W_E', uint8(2),
%$cgargs        'I_EElink', uint8(0),
%$cgargs            'reci', true,
%$cgargs           'T_N_E', zeros(4,4),
%$cgargs               'K', zeros(%NQJ%,1),
%$cgargs              'Kn', zeros(%NQJ%,1),
%$cgargs              'wn', zeros(3,1),
%$cgargs      'maxstep_ns', 0,
%$cgargs       'scale_lim', 0,
%$cgargs      'maxrelstep', 0.1,
%$cgargs'finish_in_limits', false,
%$cgargs       'normalize', false,
%$cgargs      'condlimDLS', 60,
%$cgargs      'lambda_min', 2e-4,
%$cgargs           'n_min', 0,
%$cgargs           'n_max', 1000,
%$cgargs        'rng_seed', NaN,
%$cgargs        'Phit_tol', 1.0000e-10,
%$cgargs        'Phir_tol', 1.0000e-10,
%$cgargs     'retry_limit', 100)}

%% Initialisierung

% Einstellungsvariablen aus Struktur herausholen
phiconv_W_E = s.phiconv_W_E;
K = s.K;
Kn = s.Kn;
n_min = s.n_min;
n_max = s.n_max;
wn = s.wn;
Phit_tol = s.Phit_tol;
Phir_tol = s.Phir_tol;
retry_limit = s.retry_limit;
reci = s.reci;
I_EElink = s.I_EElink;
T_N_E = s.T_N_E;
pkin = s.pkin;
NQJ = %NQJ%;
sigmaJ = s.sigmaJ; % Marker für Dreh-/Schubgelenk (in den Minimalkoordinaten)
condlimDLS = s.condlimDLS;
lambda_min = s.lambda_min;
scale_lim = s.scale_lim;
maxrelstep = s.maxrelstep;
maxstep_ns = s.maxstep_ns;
finish_in_limits = s.finish_in_limits;
break_when_in_limits = false;
n_Phi_t = sum(s.I_EE(1:3)); % Anzahl der translatorischen Zwangsbedingungen

% Indizes für kinematische Zwangsbedingungen festlegen
if reci
  % Reihenfolge hergeleitet in [SchapplerTapOrt2019]; siehe z.B. Gl. (21)
  I_IK2 = [1 2 3 6 5 4];
else
  I_IK2 = [1 2 3 4 5 6];
end
I_IK = I_IK2(s.I_EE);

% Damit der Roboter einen Nullraum für Nebenoptimierungen hat, muss er min.
% 7FG für 6FG-Aufgaben und 6FG für 5FG-Aufgaben haben.
nsoptim = false;
if NQJ > length(I_IK)
  if any(wn ~= 0)
    nsoptim = true;
  end
else
  % Keine zusätzlichen Optimierungskriterien
  finish_in_limits = false; % Alle Nullraumbewegungen nicht möglich
end
qmin = s.qlim(:,1);
qmax = s.qlim(:,2);
if all(~isnan(s.qlim(:)))
  limits_set = true;
else
  % Grenzen sind nicht wirksam
  qmin(:) = -Inf;
  qmax(:) =  Inf;
  limits_set = false;
  retry_limit = 0; % keine zufällige Neubestimmung möglich.
  finish_in_limits = false;
end
% Grenzen für die Neubestimmung der Anfangswerte (falls unendl. vorkommt).
% Annahme: Betrifft nur Drehgelenke. Dort dann zwischen -pi und pi.
% Die Variable qmin/qmax wird für Nebenbedingungen benutzt.
qmin_norm = qmin; qmax_norm = qmax;
qmin_norm(isinf(qmin)) = sign(qmin_norm(isinf(qmin)))*(pi);
qmax_norm(isinf(qmax)) = sign(qmax_norm(isinf(qmax)))*(pi);
delta_qlim = qmax - qmin;
% Variablen für Dämpfung der Inkremente
delta_q_alt = zeros(NQJ,1); % Altwert für Tiefpassfilter
damping_active = false; % Standardmäßig noch nicht aktiviert

% Zuweisung notwendig für mex (rr-Schleife nicht automatisch erkannt)
q1 = q0;
Phi = NaN(6,1); % Dimension kann sich noch verkleinern
Tc_stack = NaN(3*%NL%,4);
rejcount = 0; % Zähler für Zurückweisung des Iterationsschrittes, siehe [CorkeIK]

h = zeros(3,1); h_alt = inf(3,1); % Speicherung der Werte der Nebenbedingungen

% Ausgabe belegen
success = false;

if nargout == 4
  Stats = struct('Q', NaN(1+n_max, NQJ), 'PHI', NaN(1+n_max, 6), 'iter', n_max, ...
    'retry_number', retry_limit, 'condJ', NaN(1+n_max,1), 'lambda', ...
    NaN(n_max,2), 'rejcount', NaN(n_max,1), 'h', NaN(1+n_max,1+3));
end

%% Iterative Berechnung der inversen Kinematik
for rr = 0:retry_limit % Schleife über Neu-Anfänge der Berechnung
  % Variablen zum Speichern der Zwischenergebnisse
  q1 = q0;
  % Fehlermaß für Startwerte
  Phi_voll = %RN%_constr2(q0, Tr0E_soll, pkin, T_N_E, phiconv_W_E, I_EElink, reci);
  Phi = Phi_voll(I_IK); % Reduktion auf betrachtete FG
  if nargout == 4 % Anfangswerte eintragen
    Stats.PHI(1,:) = Phi_voll;
    Stats.Q(1,:) = q1;
  end
  lambda_mult = lambda_min; % Zurücksetzen der Dämpfung
  lambda = 0.0;
  rejcount = 0; % Zurücksetzen des Zählers für Fehlversuche
  for jj = 1:n_max % Schleife über iteratives Annähern mit Newton-Verfahren
    % Gradienten-Matrix, siehe [SchapplerTapOrt2019]/(23)
    Jdk_voll = %RN%_constr2grad(q1, Tr0E_soll, pkin, T_N_E, phiconv_W_E, I_EElink, reci);
    Jdk = Jdk_voll(I_IK,:); % Reduktion auf betrachtete FG

    %% Nullstellensuche für Positions- und Orientierungsfehler
    % (Optimierung der Aufgabe)
    % Benutze das Damped Least Squares Verfahren je nach Konditionszahl.
    % Bei Redundanz immer benutzen, nicht nur, falls Nullraumprojektion erfolglos.
    condJ = cond(Jdk);
    % manipJ = det(Jdk*Jdk'); % Manipulierbarkeit; nicht weiter verfolgt.
    if condJ > condlimDLS% && (~nsoptim || nsoptim && rejcount > 0)
      % Pseudo-Inverse mit Dämpfung:
      % Passe die Dämpfung lambda im DLS-Verfahren an. Wähle die Kon-
      % ditionszahl als Kriterium, da z.B. Grenzen für Singulärwerte
      % und Manipulierbarkeit nicht bekannt sind.
      % Skalierung zwischen 0 (z.B. Grenzfall cond=60) und 1 (komplett singulär).
      % Nehme einen Mindestwert für die Dämpfung und einen sich bei Stagnation
      % erhöhenden Aufschlag. Mit Aufschlag wird immer lambda_min benutzt.
      lambda = (-1+2*2/pi*atan(condJ/condlimDLS))*(lambda_min+lambda_mult)/2;
      % Alternative Berechnung nach [NakamuraHan1986] (nicht weiter verfolgt):
      % manipJ0 = 1e-3;
      % lambda = 0.1*(1e-3+lambda_mult)*(1-manipJ/manipJ0)^2;
      % [NakamuraHan1986], Gl. 22. Kleinere Dimension bei Redundanz als andere pinv.
      delta_q_T = ((Jdk')/(Jdk*Jdk' + lambda*eye(length(Phi))))*(-Phi);
    else
      % Normale (Pseudo-)Invertierung der Jacobi-Matrix (des Residuums):
      delta_q_T = Jdk \ (-Phi);
      lambda = 0.0;
      lambda_mult = lambda_min; % Zurücksetzen. Alles (wieder) i.O.
    end
    %% Optimierung der Nebenbedingungen (Nullraum)
    delta_q_N = zeros(size(delta_q_T));
    if nsoptim && ... % Nullraum muss vorhanden sein und Kriterien gesetzt
        jj < n_max-10 && ...% die letzten Iterationen sind zum Ausgleich des Positionsfehlers (ohne Nullraum)
        rejcount == 0 %% falls vorherige Iterationen erfolglos, keine Nullraumbewegung. Annahme: Schädlich für Konvergenz
      % Berechne Gradienten der zusätzlichen Optimierungskriterien
      v = zeros(NQJ, 1);
      if wn(1) ~= 0 % Anziehung zu Gelenkwinkel-Mitte (linear)
        [h(1), h1dq] = invkin_optimcrit_limits1(q1, [qmin, qmax]);
        v = v - wn(1)*h1dq';
      end
      if wn(2) ~= 0 % Abstoßung von den Grenzen (hyperbolisch)
        [h(2), h2dq] = invkin_optimcrit_limits2(q1, [qmin, qmax]);
        % Setze den Gradienten auf eine sehr große Zahl, wenn eine Grenze
        % überschritten wird. Sonst auch Abbruch bei unendlich.
        % Die Nullraumbewegung wird später sowieso reduziert.
        h2dq(q1>=qmax) = 1e10; h2dq(q1<=qmin) = -1e10;
        v = v - wn(2)*h2dq';
      end
      if wn(3) ~= 0 % Singularitäts-Kennzahl mit Log-Konditionszahl
        hdq = NaN(1,NQJ);
        for kkk = 1:NQJ % Differenzenquotient für jede Gelenkkoordinate
          q_test = q1; % ausgehend von aktueller Konfiguration
          q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
          Jdk_voll_kkk = %RN%_constr2grad(q_test, Tr0E_soll, pkin, T_N_E, phiconv_W_E, I_EElink, reci);
          Jdk_kkk = Jdk_voll_kkk(I_IK,:); % Berechnung identisch mit oben
          condJ_kkk = cond(Jdk_kkk);
          % Differenzenquotient aus Log-Kond. scheint bei hohen Konditions-
          % zahlen numerisch etwas besser zu dämpfen (sonst dort sofort
          % maximal große Sprünge der Gelenkwinkel). Dafür Gradient dort zu gering.
          hdq(kkk) = (condJ_kkk-condJ)/1e-6;
        end
        v = v - wn(3)*hdq';
        h(3) = condJ;
      end
      % [SchapplerTapOrt2019]/(35); [1], Gl. (24)
      delta_q_N(:) = (eye(NQJ) - pinv(Jdk)* Jdk) * v; % "(:)" notwendig für mex
    end

    % Reduziere Schrittweite auf einen absoluten Wert. Annahme: Newton-
    % Raphson-Verfahren basiert auf Linearisierung. Kleinwinkelnäherung
    % wird verlassen, wenn alle Gelenkwinkel in Summe mehr als 20° drehen.
    % (moderate Annahme, dass die Gelenke einigermaßen gleichgerichtet drehen)
    % Führe das getrennt für delta_q_T und delta_q_N durch, damit die 
    % Nullraumbewegung nicht die Aufgabenbewegung dominieren kann.
    delta_q_T = K.*delta_q_T;
    delta_q_N = Kn.*delta_q_N;
    sum_abs_delta_qTrev = sum(abs(delta_q_T(sigmaJ==0))); % nur Drehgelenke
    if sum_abs_delta_qTrev > 0.35 % 0.35rad=20°
      % Reduziere das Gelenk-Inkrement so, dass die Summe der Beträge
      % danach 20° ist.
      delta_q_T = delta_q_T .* 0.35/sum_abs_delta_qTrev;
    end
    sum_abs_delta_qNrev = sum(abs(delta_q_N(sigmaJ==0))); % nur Drehgelenke
    if sum_abs_delta_qNrev > 0.035 % 0.035rad=2°
      % Reduziere das Gelenk-Inkrement so, dass die Summe der Beträge
      % danach 2° ist. Sehr kleine Schritte, damit nur sehr kleine
      % Verschlechterung des Residuums durch die Nullraumbewegung.
      % Bei 2° wird die lokale Näherung allerdings schon leicht verlassen.
      delta_q_N = delta_q_N .* 0.035/sum_abs_delta_qNrev;
    end

    % [SchapplerTapOrt2019]/(35); [1], Gl. (23)
    % Verstärkungsfaktoren K und Kn oben bereits angewendet.
    delta_q = delta_q_T + delta_q_N;
    
    % Reduziere Schrittweite (qT+qN gemeinsam) auf einen Maximalwert
    % bezogen auf Winkelgrenzen (bzw. auf die mögliche Spannweite)
    if limits_set && ~isnan(maxrelstep)
      % Bestimme Inkrement relativ zur Spannbreite der Grenzen
      abs_delta_q_rel = abs(delta_q ./ delta_qlim);
      if any(abs_delta_q_rel > maxrelstep)
        % Ein Element hat ein zu großes Inkrement. Normiere den
        % Inkrement-Vektor damit
        delta_q = delta_q .* maxrelstep / max(abs_delta_q_rel);
      end
    end
    % Zusätzlicher Dämpfungsterm (gegen Oszillationen insbesondere der
    % Nullraumbewegung). Aktiviere, sobald Oszillationen erkannt werden
    if damping_active
      % Benutze diskretes PT1-Filter mit T=2 (Schritte der IK) und K=1
      delta_q = delta_q_alt + 1/(1+2)*(1*delta_q-delta_q_alt);
      delta_q_alt = delta_q; % bei Aktivierung des Filters noch auf Null. Ist egal.
    elseif all(sign(delta_q) == -sign(delta_q_alt))
      damping_active = true; % ab jetzt aktiviert lassen.
    end
    
    % Gelenkwinkel-Schritt anwenden
    q2 = q1 + delta_q;
    
    % Prüfe, ob die Gelenkwinkel ihre Grenzen überschreiten und reduziere
    % die Schrittweite, falls das der Fall ist
    if scale_lim
      delta_ul_rel = (qmax - q2)./(qmax-q1); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qmin + q2)./(q1-qmin); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        % Berechne die prozentual stärkste Überschreitung
        % und nutze diese als Skalierung für die Winkeländerung
        % Reduziere die Winkeländerung so, dass die gröte Überschreitung auf
        % das Erreichen der Grenzen reduziert wird.
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qmax(I_max)-q1(I_max))./(delta_q(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qmin(I_min)-q1(I_min))./(delta_q(I_min));
        end
        % Mit `scale` werden die Grenzen direkt für ein Gelenk erreicht.
        % Durch `scale_lim` wird dieses Erreichen weiter nach "innen" gezogen
        delta_q = scale_lim*scale*delta_q;
        q2 = q1 + delta_q;
      end
    end

    if any(isnan(q2)) || any(isinf(q2))
      if nargout == 4
        Stats.iter = jj;
      end
      break; % ab hier kann das Ergebnis nicht mehr besser werden wegen NaN/Inf
    end

    % Fehlermaß für aktuelle Iteration (wird auch in nächster Iteration benutzt)
    Phi_voll = %RN%_constr2(q2, Tr0E_soll, pkin, T_N_E, phiconv_W_E, I_EElink, reci);
    Phi_neu = Phi_voll(I_IK);
    % Prüfe, ob Wert klein genug ist. Bei kleinen Zahlenwerten, ist
    % numerisch teilweise keine Verbesserung möglich.
    Phi_iO = all(abs(Phi_neu(1:n_Phi_t)) < Phit_tol) && ...
             all(abs(Phi_neu(n_Phi_t+1:end)) < Phir_tol);
    if Phi_iO && any(delta_q_N) && sum(wn.*h)>=sum(wn.*h_alt)
      % Prüfe, ob sich die Nebenbedingungen überhaupt noch verbessern. Wenn
      % nicht, kann auch abgebrochen werden. Variable delta_q_N dient zur
      % Ablaufsteuerung für folgende Abfragen (nicht für Ergebnis selbst).
      delta_q_N(:) = 0;
    end
    % Prüfe, ob Schritt erfolgreich war (an dieser Stelle, da der 
    % Altwert von Phi noch verfügbar ist). Siehe [CorkeIK].
    Delta_Phi = norm(Phi_neu) - norm(Phi); % "neu" - "alt";
    if any(delta_q_N) && sum(wn.*h)>=sum(wn.*h_alt) && Delta_Phi > 0
      % Zusätzliches Optimierungskriterium hat sich verschlechtert und
      % gleichzeitig auch die IK-Konvergenz. Das deutet auf eine
      % Konvergenz mit Oszillationen hin. Reduziere den Betrag der
      % Nullraumbewegung. Annahme: Bewegung so groß, dass keine
      % Linearisierungsfehler (außerhalb des Nullraums) zu groß.
      Kn = Kn*0.8;
    end
    if Phi_iO || Delta_Phi < 0 ... % Verbesserung des Residuums
        || any(delta_q_N) && all(abs(Phi_neu)<1e-3) && any(delta_q) % Bei Nullraumbewegung auch Verschlechterung möglich, wenn noch im "guten" Bereich
      if condJ>1e4 && Delta_Phi > -Phit_tol % Singularität mit Mini-Schritten
        % Erhöhe Dämpfung um von Singularität wegzukommen. Falls das nicht
        % funktioniert, führt das immerhin zu einem relativ frühen Abbruch,
        % da lambda gegen unendlich geht und dann sich Phi nicht mehr mit
        % Minimal-Schritten numerisch verbessert.
        lambda_mult = lambda_mult*2;
      else
        % Erfolgreich. Verringere lambda bis auf Minimalwert.
        lambda_mult = max(lambda_mult/2, lambda_min); % Singularität überwunden
      end
      % Behalte Ergebnis der Iteration für weitere Iterationen.
      q1 = q2;
      h_alt = h;
      % Behalte Wert für Phi nur in diesem Fall. Dadurch wird auch die Verbesserung
      % gegenüber der Iteration messbar, bei der zuletzt eine Verschlechterung eintrat.
      Phi = Phi_voll(I_IK); % Reduktion auf betrachtete FG
      rejcount = 0;
    else
      % Kein Erfolg. Erhöhe die Dämpfung. Mache den Schritt nicht.
      % Setzt voraus, dass die Konditionszahl so schlecht ist, dass
      % oben das DLS-Verfahren benutzt wird. Ansonsten Stillstand.
      lambda_mult = lambda_mult*2;
      rejcount = rejcount + 1;
      if condJ <= condlimDLS && ~nsoptim || ... % Keine Verbesserung der Konvergenz trotz guter Konditionszahl.
       rejcount > 50 % Stillstand zu lange trotz exponentieller Erhöhung von lambda.
        % Abbruch. Keine Verbesserung mit Algorithmus möglich.
        if nargout == 4
          Stats.iter = jj;
        end
        break;
      end
    end
    if nargout == 4
      Stats.Q(1+jj,:) = q1;
      Stats.PHI(1+jj,:) = Phi_voll;
      Stats.h(jj,:) = [sum(wn.*h),h'];
      Stats.condJ(jj) = condJ;
      Stats.lambda(jj,:) = [lambda, lambda_mult];
      Stats.rejcount(jj) = rejcount;
    end
    % Prüfe Abbruchbedingung für Einhaltung der Winkelgrenzen. Ist dies bei
    % "finish_in_limits" der Fall, muss die IK nur noch konvergiert sein.
    if break_when_in_limits && (all(q1 >= qmin) && all(q1 <= qmax))
      delta_q_N(:) = 0; % unvollständige Nullraumbewegung wird hiernach ignoriert.
      % hiernach dürfen die Grenzen nicht mehr verlassen werden (falls
      % noch weitere Iterationen gemacht werden)
      scale_lim = 0.7;
      % Reduziere die Nullraumbewegung ab hier ganz stark. Damit können die
      % Grenzen noch leicht nachkorrigiert werden, es dominiert aber die
      % Aufgabenbewegung.
      Kn = Kn*0.8;
    end
    % Abbruchbedingungen prüfen
    if jj >= n_min ... % Mindestzahl Iterationen erfüllt
        && Phi_iO && ... % Haupt-Bedingung ist erfüllt
        ( ~nsoptim || ... %  und keine Nebenoptimierung läuft
        nsoptim && all(abs(delta_q_N) < maxstep_ns) ) % oder die Nullraumoptimierung läuft noch
      success = true;
      if nargout == 4
        Stats.iter = jj; % muss hier zugewiesen werden (für mex)
      end
      if finish_in_limits && (any(q1 < qmin) || any(q1 > qmax))
        % Es soll eigentlich abgebrochen werden. Die Grenzen wurden aber 
        % nicht eingehalten. Mache noch mit dem Algorithmus weiter und 
        % optimiere nur noch die Grenzen (und nicht z.B. Konditionszahl)
        finish_in_limits = false; % Modus ist damit aktiviert
        nsoptim = true;
        wn = [0;1;0]; % Nutze nur die hyperbolische Funktion des Abstands
        % Mache diese Optimierung nicht mehr zu Ende, sondern höre auf, 
        % wenn die Grenzen erreicht sind.
        break_when_in_limits = true;
        continue
      end
      break;
    end
  end
  if success
    if nargout == 4
      Stats.retry_number = rr;
    end
    break;
  end
  % Beim vorherigen Durchlauf kein Erfolg. Generiere neue Anfangswerte
  if rr == 0 && ~isnan(s.rng_seed)
    rng(s.rng_seed); % Initialisiere Zufallszahlen, falls gewünscht
  end
  q0(:) = qmin_norm + rand(NQJ,1).*(qmax_norm-qmin_norm); % "(:)" notwendig für mex
end
if nargout == 4 % Berechne Leistungsmerkmale für letzten Schritt
  if wn(1) ~= 0, h(1) = invkin_optimcrit_limits1(q1, [qmin, qmax]); end
  if wn(2) ~= 0, h(2) = invkin_optimcrit_limits2(q1, [qmin, qmax]); end
  Jdk_voll = %RN%_constr2grad(q1, Tr0E_soll, pkin, T_N_E, phiconv_W_E, I_EElink, reci);
  Jdk = Jdk_voll(I_IK,:);
  h(3) = cond(Jdk);
  Stats.h(Stats.iter+1,:) = [sum(wn.*h),h'];
  Stats.condJ(Stats.iter+1) = h(3);
end

q = q1;
if s.normalize
  q(sigmaJ==0) = normalize_angle(q(sigmaJ==0)); % nur Winkel normalisieren
end
if nargout >= 3
  [~, Tc_stack] = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, pkin);
end

