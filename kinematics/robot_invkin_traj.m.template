% Inverse Kinematik für komplette Trajektorie für
% %RN%
% Allgemeine, stark parametrierbare Funktion zum Aufruf mit allen möglichen
% Einstellungen
% Iterative Lösung der inversen Kinematik mit inverser Jacobi-Matrix
% Zusätzlich Nutzung der differentiellen Kinematik für schnellere Konvergenz
% (Es wird vorausgesetzt und ausgenutzt, dass die EE-Trajektorie stetig ist)
%
% Eingabe:
% X [NT x 6]
%   Trajektorie von EE-Lagen (Sollwerte) für NT Zeitschritte aus T
% XD [NT x 6]
%   Trajektorie von EE-Geschwindigkeiten (Sollwerte)
%   (Die Orientierung wird durch Euler-Winkel-Zeitableitung dargestellt)
% XDD [NT x 6]
%   Trajektorie von EE-Beschleunigungen (Sollwerte)
%   Orientierung bezogen auf Euler-Winkel
% T [NT x 1]
%   Zeitbasis der Trajektorie (Alle Zeit-Stützstellen)
% q0 [%NQJ% x 1]
%   Anfangs-Gelenkwinkel für Algorithmus
% s
%   Struktur mit Eingabedaten. Felder, siehe Quelltext dieser Funktion und
%   von `%RN%_invkin_eulangresidual` sowie aufrufende Methode aus
%   SerRob-Klasse. Zusätzliche Felder gegenüber invkin-Funktion. Auswahl:
%   .wn [25x1] Gewichtungen der Zielfunktionen für Nullraumbewegung
%     Indiziert mit idx_iktraj_wnP und idx_iktraj_wnD aus ik_optimcrit_index.m
%     (1) Quadratischer Abstand der Gelenkkoordinaten von ihrer Mitte
%         (zu h(1))
%     (2) Hyperbolischer Abstand der Gelenkkoordinaten von ihren Grenzen
%         (zu h(2))
%     (3) Quadratischer Abstand der Gelenkgeschwindigkeiten von ihrer Mitte
%         (zu h(3))
%     (4) Hyperbolischer Abstand der Gelenkgeschwindigkeiten von ihren Grenzen
%         (zu h(4))
%     (5) Konditionszahl der IK-Jacobi-Matrix (Aufgaben-FG)
%         (zu h(5))
%     (6) Konditionszahl der geometrischen Jacobi-Matrix
%         (zu h(6))
%     (7) Wie Eintrag 1, aber auf Geschwindigkeitsebene
%     (8) Wie Eintrag 2, aber auf Geschwindigkeitsebene
%     (9) Wie Eintrag 5, aber auf Geschwindigkeitsebene
%    (10) Wie Eintrag 6, aber auf Geschwindigkeitsebene
%    (11) Abstand der Kollisionskörper voneinander (hyperbolisch gewertet)
%         (zu h(7))
%    (12) wie 11, aber auf Geschwindigkeitsebene
%    (13) Abstand von Prüfkörpern des Roboters zur Bauraumgrenze (hyperbolisch)
%         (zu h(8))
%    (14) wie 13, aber auf Geschwindigkeitsebene
%    (15) Abstand von phiz zu xlim (quadratisch gewertet)
%         (zu h(9))
%    (16) wie 15, aber auf Beschleunigungsebene
%    (17) Abstand von phiz zu xlim (hyperbolisch gewertet)
%         (zu h(10))
%    (18) wie 17, aber auf Beschleunigungsebene
%    (19) Abstand von phizD zu xDlim (quadratisch gewertet) als Dämpfung
%         (zu h(11))
%    (20) Abstand der Kollisionskörper voneinander (quadratisch gewertet)
%         (zu h(12))
%    (21) Wie 20, aber D-Anteil
%    (22) Abstand von Prüfkörpern des Roboters zur Bauraumgrenze (quadratisch)
%         (zu h(13))
%    (23) wie 22, aber auf Geschwindigkeitsebene
%    (24) Positionsfehler am Endeffektor
%    (25) Wie 20, aber D-Anteil
%
% Ausgabe:
% Q [NT x %NQJ%]
%   Trajektorie von Gelenkpositionen (Lösung der IK)
% QD [NT x %NQJ%]
%   Trajektorie von Gelenkgeschwindigkeiten
% QDD [NT x %NQJ%]
%   Trajektorie von Gelenkbeschleunigungen
% PHI
%   Fehlermaß der inversen Kinematik für alle Zeitschritte
% JointPos_all [NT x (%NQJ%*3)]
%   gestapelte Positionen aller Gelenke für alle Zeitschritte
%   (Entspricht letzter Spalte aller homogener Transformationsmatrizen)
% Stats
%   Struktur mit Detail-Ergebnissen für den Verlauf der Berechnung. Felder:
%   .condJ (NT x 2): (1.) Konditionszahl der analytischen Jacobi-Matrix
%     (bezogen auf Aufgaben-FG). (2.)  Konditionszahl der geometrischen 
%     Jacobi-Matrix ohne Betrachtung von Aufgaben-Red.
%   .errorcode [1x1]: Grund für den frühzeitigen Abbruch der Trajektorie.
%     0: alles in Ordnung
%     1: Fehler Positions-IK
%     2: Ungültiger Wert für nächste Iteration (NaN im Nullraum)
%     3: Abbruch durch Überschreitung von Zielkriterien
%
% Siehe auch: ParRob/invkin_traj

% TODO: EE-Trajektorie auch als Winkelgeschwindigkeit und zusätzlicher
%       Schalter für Umrechnung auf analytische Jacobi-Matrix
% TODO: Bei Verletzung von qD ist qD/qDD leicht inkonsistent.

% Quelle:
% [1] Aufzeichnungen Schappler vom 28.11.2018
% [2] Aufzeichnungen Schappler vom 11.12.2018
% [3] Aufzeichnungen Schappler vom 06.07.2020
% [4] Aufzeichnungen Schappler vom 25.03.2020
% [RMG16] Reiter et al.: Inverse Kinematics in Minimum-Time Trajectory
% Planning for Kinematically Redundant Manipulators (2016)
% [RMG18] Reiter et al.: On higher order inverse kinematics methods in 
% time-optimal trajectory planning for kinematically redundant manipulators (2018)
% [SchapplerOrt2021] Schappler, M. et al.: Singularity Avoidance of Task-
% Redundant Robots in Pointing Tasks (...); ICINCO 2021


% Generated in SerRobLib from template file in robotics repo
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2019-02
% (C) Institut für Mechatronische Systeme, Leibniz Universität Hannover

function [Q, QD, QDD, PHI, JointPos_all, Stats] = %RN%_invkin_traj(X, XD, XDD, T, q0, s)

%% Coder Information
%#codegen
%$cgargs {coder.newtype('double',[inf,6]),coder.newtype('double',[inf,6]),
%$cgargs  coder.newtype('double',[inf,6]),coder.newtype('double',[inf,1]),
%$cgargs zeros(%NQJ%,1), struct(
%$cgargs            'pkin', zeros(%NKP%,1),
%$cgargs          'sigmaJ', zeros(%NQJ%,1),
%$cgargs            'qlim', zeros(%NQJ%,2),
%$cgargs           'qDlim', zeros(%NQJ%,2),
%$cgargs          'qDDlim', zeros(%NQJ%,2),
%$cgargs    'enforce_qlim', false,
%$cgargs   'enforce_qDlim', false,
%$cgargs    'enforce_xlim', false,
%$cgargs   'enforce_xDlim', false,
%$cgargs            'xlim', zeros(6,2),
%$cgargs           'xDlim', zeros(6,2),
%$cgargs          'xDDlim', zeros(6,2),
%$cgargs 'xlim6_interp', coder.newtype('double',[3,inf]),
%$cgargs        'q_poserr', ones(%NQJ%,1),
%$cgargs 'nullspace_maxvel_interp', coder.newtype('double',[2,inf]),
%$cgargs            'I_EE', true(1,6),
%$cgargs     'phiconv_W_E', uint8(2),
%$cgargs        'I_EElink', uint8(0),
%$cgargs            'reci', true,
%$cgargs    'simplify_acc', false,
%$cgargs    'ik_solution_min_norm', true,
%$cgargs 'optimcrit_limits_hyp_deact', 0.9,
%$cgargs  'cond_thresh_ikjac', 1,
%$cgargs  'cond_thresh_jac', 1,
%$cgargs           'T_N_E', zeros(4,4),
%$cgargs               'K', zeros(%NQJ%,1),
%$cgargs           'debug', false,
%$cgargs              'wn', zeros(25,1),
%$cgargs  'abort_thresh_h', zeros(14,1),
%$cgargs      'maxrelstep', 0.1,
%$cgargs       'normalize', false,
%$cgargs           'n_min', 0,
%$cgargs           'n_max', 1000,
%$cgargs        'rng_seed', NaN,
%$cgargs        'Phit_tol', 1.0000e-10,
%$cgargs        'Phir_tol', 1.0000e-10,
%$cgargs      'collbodies', struct(
%$cgargs                    'link',   coder.newtype('uint8',[inf,2]),
%$cgargs                    'type',   coder.newtype('uint8',[inf,1]),
%$cgargs                    'params', coder.newtype('double',[inf,10])),
%$cgargs 'collbodies_thresh', 1.5, 
%$cgargs  'collision_thresh', NaN,
%$cgargs      'collchecks', coder.newtype('uint8',[inf,2]),
%$cgargs 'installspace_thresh', 0.1, 
%$cgargs  'collbodies_instspc', struct(
%$cgargs                    'link',   coder.newtype('uint8',[inf,2]),
%$cgargs                    'type',   coder.newtype('uint8',[inf,1]),
%$cgargs                    'params', coder.newtype('double',[inf,10])),
%$cgargs 'collchecks_instspc', coder.newtype('uint8',[inf,2]))}

%% Initialisierung
% Vorbelegung der Ausgabe
Q = NaN(length(T), %NQJ%);
QD = Q;
QDD = Q;
PHI = NaN( length(T), sum(s.I_EE) );
JointPos_all = NaN( length(T), (%NJ%+1+1)*3 );

% Einstellungsvariablen aus Struktur herausholen
NQJ = %NQJ%;
I_EE = s.I_EE;
Rob_I_EE = %Rob_I_EE%; % Strukturelle FG (im Gegensatz zu Aufgaben-FG aus s.I_EE)
n_Phi_t = sum(s.I_EE(1:3));
nt = length(T);
link_index = s.I_EElink;
pkin = s.pkin;
r_i_i_C = s.T_N_E(1:3,4);
% Prüfe, ob Grenzen für die Position gesetzt wurden
qlim = s.qlim;
qmin = qlim(:,1);
qmax = qlim(:,2);
if all(~isnan(s.qlim(:)))
  limits_q_set = true;
else
  % Grenzen sind nicht wirksam
  qmin(:) = -Inf;
  qmax(:) =  Inf;
  limits_q_set = false;
end
% Prüfe, ob Grenzen für die Geschwindigkeit gesetzt wurden
qDlim = s.qDlim;
if all(~isnan(s.qDlim(:)))
  limits_qD_set = true;
else
  limits_qD_set = false;
end
% Prüfe, ob Grenzen für die Beschleunigung gesetzt wurden
qDDlim = s.qDDlim;
qDDmin = qDDlim(:,1);
qDDmax = qDDlim(:,2);
if all(~isnan(s.qDDlim(:)))
  limits_qDD_set = true;
else
  % Grenzen sind nicht wirksam
  qDDmin(:) = -Inf;
  qDDmax(:) =  Inf;
  limits_qDD_set = false;
end
if ~all(isnan(s.xDDlim(:)))
  limits_xDD_set = true;
else
  limits_xDD_set = false;
end
if ~all(isnan(s.xDlim(:)))
  limits_xD_set = true;
else
  limits_xD_set = false;
end
enforce_qlim = s.enforce_qlim;
enforce_qDlim = s.enforce_qDlim;
enforce_xlim = s.enforce_xlim;
enforce_xDlim = s.enforce_xDlim;
% Schwellwert in Gelenkkoordinaten für Aktivierung des Kriteriums für 
% hyperbolisch gewichteten Abstand von den Grenzen.
qlim_thr_h2 = repmat(mean(qlim,2),1,2) + repmat(qlim(:,2)-qlim(:,1),1,2).*...
  repmat([-0.5, +0.5]*s.optimcrit_limits_hyp_deact,NQJ,1);
% Schwellwert der Z-Rotation (3T2R) für Aktivierung des Kriteriums für 
% hyperbolisch gewichteten Abstand von den Grenzen.
xlim = s.xlim;
xlim_thr_h10 = repmat(mean(xlim,2),1,2) + repmat(xlim(:,2)-xlim(:,1),1,2).*...
  repmat([-0.5, +0.5]*0.8,6,1); % vorläufig auf 80% der Grenzen in xlim
if ~all(isnan(xlim(:))) || ~isempty(s.xlim6_interp)
  limits_x_set = true;
else
  limits_x_set = false;
end
wn = s.wn;
if any(wn ~= 0)
  nsoptim = true;
else
  % Keine zusätzlichen Optimierungskriterien
  nsoptim = false;
end
% Damit der Roboter einen Nullraum für Nebenoptimierungen hat, muss er min.
% 7FG für 6FG-Aufgaben und 6FG für 5FG-Aufgaben haben.
if sum(I_EE) >= NQJ
  % Keine Optimierungen im Nullraum möglich
  nsoptim = false;
  % Keine Redundanz vorliegend
  redundant = false;
else
  % Redundanz vorliegend. Wird für Nullraumoptimierung und weitere
  % Nullraumbewegungen genutzt.
  redundant = true;
end
% Stelle fest, ob Schwellen der Zielfunktion zum Abbruch führen sollen
if ~nsoptim && any(~isnan(s.abort_thresh_h))
  % Setze Marker, damit auch im nicht-redundanten Fall die Zielkriterien
  % berechnet werden
  calc_h_nored = true;
else
  calc_h_nored = false;
end
[~, ~, idx_wnP, idx_wnD, idx_hn, idx_ik_length] = ik_optimcrit_index(0);
% Definitionen für die Kollisionsprüfung
collbodies_ns = s.collbodies;
maxcolldepth = 0;
collobjdist_thresh = 0;
if isempty(collbodies_ns.type) % Keine Kollisionskörper
  wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp,idx_wnP.coll_par,idx_wnD.coll_par]) = 0; % Deaktivierung der Kollisionsvermeidung
end
if isempty(s.collbodies_instspc.type) % Keine Bauraum-Prüfkörper
  wn([idx_wnP.instspc_hyp,idx_wnD.instspc_hyp,idx_wnP.instspc_par,idx_wnD.instspc_par]) = 0; % Deaktivierung der Bauraumprüfung
end
if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp,idx_wnP.coll_par,idx_wnD.coll_par]))
  % Kollisionskörper für die Kollisionserkennung z.B. 50% größer machen.
  % Ist zusammen mit dem Schwellwert für die Kollisionsvermeidung wirksam.
  collbodies_ns.params(collbodies_ns.type==6,1) = ... % Kapseln (Direktverbindung)
    s.collbodies_thresh*collbodies_ns.params(collbodies_ns.type==6,1);
  collbodies_ns.params(collbodies_ns.type==13,7) = ... % Kapseln (Basis-KS)
    s.collbodies_thresh*collbodies_ns.params(collbodies_ns.type==13,7);
  collbodies_ns.params(collbodies_ns.type==4|collbodies_ns.type==15,4) = ... % Kugeln
    s.collbodies_thresh*collbodies_ns.params(collbodies_ns.type==4|collbodies_ns.type==15,4);
  % Maximal mögliche Eindringtiefe der Warnungs-Ersatzkörper bestimmen um
  % daraus die Grenzen der hyperbolischen Kollisionsfunktion zu bestimmen.
  % Ist eine etwas größere Schätzung (abhängig von relativer Größe von
  % Kugeln und Zylindern)
  maxcolldepth = max([0; collbodies_ns.params(collbodies_ns.type==6,1);  ... % 1. Eintrag damit nicht leer
                         collbodies_ns.params(collbodies_ns.type==13,7); ...
                         collbodies_ns.params(collbodies_ns.type==4|collbodies_ns.type==15,4)]);
  % Abstand der Objekte, ab dem die Zielfunktion anfängt (bei größeren
  % Abständen ist sie Null). Dies Wert muss kleiner sein als der, ab dem die
  % Erkennung beginnt (sonst Sprung). Unklar, ob dieser Wert immer passt.
  % Die Erkennung wird durch `collbodies_ns` bestimmt. Diese müssen also
  % eher zu groß gewählt werden (über Parameter collbodies_thresh).
  % je kleiner der Wert wird, desto später wird die Vermeidung wirksam
  collobjdist_thresh = 0.3 * maxcolldepth;
end
if ~isnan(s.collision_thresh)
  collobjdist_thresh = s.collision_thresh;
end

simplify_acc = s.simplify_acc;
% Einstellungsvariable für Positions-IK zusammenstellen. Fast alle sind
% gleich. Es dürfen aber keine überzähligen Felder übergeben werden.
s_pik = struct( ...
  'pkin', s.pkin, ...
  'sigmaJ', s.sigmaJ, ...
  'qlim', s.qlim, ...
  'xlim', s.xlim, ... % hat keinen Einfluss (ohne Nullraumbewegung)
  'q_poserr', s.q_poserr, ...
  'I_EE', s.I_EE, ...
  'phiconv_W_E', s.phiconv_W_E, ...
  'I_EElink', s.I_EElink, ...
  'reci', s.reci, ...
  'T_N_E', s.T_N_E, ...
  'K', s.K, ...
  'Kn', zeros(%NQJ%,1), ... % Keine Nullraumoptimierung sinnvoll. ...
  'wn', zeros(idx_ik_length.wnpos,1), ... % ... Wird in Traj. gemacht.
  'maxstep_ns', 0, ... % keine Bedeutung, da keine Nullraumbewegung möglich
  'scale_lim', 0, ... % Herunterskalieren nicht sinnvoll ...
  'scale_coll', 0, ... % (da keine Nullraum-Bewegung)
  'maxrelstep', s.maxrelstep, ... 
  'finish_in_limits', false, ... % Ohne Nullraumbewegung nicht möglich
  'avoid_collision_finish', false, ... % s.o.
  'optimcrit_limits_hyp_deact', NaN, ... % nicht relevant (da keine Nullraumbewegung)
  'cond_thresh_ikjac', NaN, ... % nicht relevant
  'cond_thresh_jac', NaN, ... % nicht relevant
  'normalize', s.normalize, ... 
  'condlimDLS', 1, ... 
  'lambda_min', 2e-4, ... 
  'n_min', s.n_min, ...
  'n_max', s.n_max, ...
  'rng_seed', s.rng_seed, ...
  'Phit_tol', s.Phit_tol, ...
  'Phir_tol', s.Phir_tol, ...
  'retry_on_limitviol', false, ... % nicht sinnvoll
  'retry_limit', 0, ...
  'collbodies', struct(... % Dummy-Eintrag für Kompilierbarkeit
    'link', uint8(zeros(1,2)), ...
    'type', uint8(zeros(1,1)), ...
    'params', zeros(1,10)), ...
  'collbodies_thresh', 1.5, ... % keine Wirkung
  'collision_thresh', NaN, ... % keine Wirkung
  'collchecks', uint8(zeros(1,2)), ... % Dummy-Eintrag
  'installspace_thresh', 0.100, ... % keine Wirkung
  'collbodies_instspc', struct(... % Dummy-Eintrag für Kompilierbarkeit
    'link', uint8(zeros(1,2)), ... %
    'type', uint8(zeros(1,1)), ... %
    'params', zeros(1,10)), ...
  'collchecks_instspc', uint8(zeros(1,2))); % Dummy-Eintrag
% Gelenkkonfiguration, bei der Nebenbed. 5 (Kondition) das letzte mal
% berechnet wurde
q_wn5 = inf(NQJ,1);
% Gradient von Nebenbedingung 5, 6, 7, 8 und 13 und 24
h5dq = NaN(1,NQJ); h6dq=h5dq; h7dq=h5dq; h8dq=h5dq; h13dq = h5dq; h24dq = h5dq;
% Zuweisung notwendig für mex (u.a. k-Schleife wird nicht vollständig erkannt)
qk0 = q0;
qDNk0 = zeros(NQJ,1);
qD_k_T = zeros(NQJ,1);
qDD_k_T = zeros(NQJ,1);
qD_k = zeros(NQJ,1);
qD_N_pre_alt = zeros(NQJ,1);
qDD_N_pre = zeros(NQJ,1);
qDD_N_pre1 = zeros(NQJ,1);
N = zeros(NQJ,NQJ);
x_k_ist = NaN(6,1);
xD_k_ist = NaN(6,1);
phizDlim = s.xDlim(6,:);
phizD_N_lim = s.xDlim(6,:);
qD_N_lim_noscale = NaN(NQJ,2);
qD_N_lim = NaN(NQJ,2);
vmax_rel_lastvel = 1; % Skalierung der Geschwindigkeitsgrenzen
dt = 0; % Initialisierung, wird überschrieben.
J_x_alt = zeros(6,NQJ);
Stats = struct('file', 'robot_invkin_traj', 'iter', 0, 'h', NaN(nt,1+idx_ik_length.hntraj), ...
  'h_instspc_thresh', NaN, 'condJ', NaN(nt,2), 'h_coll_thresh', NaN, ...
  'errorcode', 0, 'version', 8);
h = zeros(idx_ik_length.hntraj,1);
%% Iterative Berechnung der gesamten Trajektorie
for k = 1:nt
  x_k = X(k,:)';
  Tr0E_k = [eul2r(X(k,4:6)', s.phiconv_W_E), X(k,1:3)'];
  if k < nt % Schrittweite für letzten Zeitschritt angenommen wie vorletzter
    dt = T(k+1)-T(k); % Zeit bis zum nächsten Abtastpunkt
  end
  %% Gelenk-Position berechnen
  % Inverse Kinematik für aktuellen Bahnpunkt. Nutze Anfangswert aus der
  % differentiellen Kinematik hiernach von der letzten Iteration (k-1)
  [q_k, Phi_k, Tc_stack_k, Stats_k] = %RN%_invkin_eulangresidual(Tr0E_k, qk0, s_pik);
  Phi_k_voll = Stats_k.PHI(1+Stats_k.iter,:)';
  % Abspeichern für Ausgabe.
  Q(k,:) = q_k;
  PHI(k,:) = Phi_k;
  JointPos_all(k,:) = Tc_stack_k(:,4);
  % Prüfe Erfolg der IK
  if any(abs(Phi_k(1:n_Phi_t)) > s_pik.Phit_tol) || ...
     any(abs(Phi_k(n_Phi_t+1:end)) > s_pik.Phir_tol) || ...
     any(isnan(Phi_k)) || any(isnan(q_k))
    Stats.errorcode = 1;
    break; % Die IK kann nicht gelöst werden. Weitere Rechnung ergibt keinen Sinn.
  end
  %% Gelenk-Geschwindigkeit berechnen
  % Geometrische Jacobi-Matrix in analytische Jacobi umrechnen (siehe [1]).
  Jg = %RN%_jacobig_sym_varpar(q_k, link_index, r_i_i_C, pkin);
  Tw = euljac(X(k,4:6)', s.phiconv_W_E); % Euler-Transformationsmatrix
  J_x = [Jg(1:3,:); Tw \ Jg(4:6,:)]; % analytische Jacobi-Matrix
  condJik = cond(J_x(I_EE,:)); condJ = cond(Jg(Rob_I_EE,:));
  Stats.condJ(k,:) = [condJik, condJ];
  % Gelenk-Geschwindigkeit mit inverser Jacobi
  % resultierend aus Aufgabe 
  if s.ik_solution_min_norm % (minimale Norm der Geschw.)
    qD_k_T(:) = J_x(I_EE,1:NQJ) \ XD(k,I_EE)';
  else % Vorgesteuerte Geschwindigkeit auch bei Aufgabenredundanz möglich
    qD_k_T(:) = J_x(Rob_I_EE,1:NQJ) \ XD(k,Rob_I_EE)';
  end
  xD_k_T_ist = J_x * qD_k_T;
  xD_k_ist = J_x * qD_k;
  if ~(nsoptim || redundant)
    qD_k = qD_k_T; % ohne Redundanz nur Aufgaben-Geschw.; eindeutig.
  else
    % Bestimme Korrekturterm zum Ausgleich des Linearisierungsfehlers aus der
    % letzten Iteration (k-1). Ausgleich der Nullraumbewegung, die aus der
    % Beschleunigung berechnet wird. Siehe [3].
    % EE-Geschw. mit der Gelenk-Geschw. aus dem vorherigen Zeitschritt
    % (k-1) berechnet für diesen Zeitschritt (k). Ein Teil von qDNk0 geht in
    % den Nullraum. Daher kann nicht einfach obige Formel genommen werden.
    xD_pre = J_x(I_EE,:)*(qD_k_T + qDNk0);
    % Korrektur-Term der Geschwindigkeit: Die Gelenk-Geschwindigkeit mit
    % Berechnung aus (k-1) führt nicht zur korrekten EE-Geschw. in (k)
    xD_korr = -xD_pre+XD(k,I_EE)'; % dieses Residuum sollte klein bleiben
    % Korrekturwert für Gelenk-Geschw. berechnet mit Pseudo-Inverse (ohne
    % Nullraumoptimierung, da nur Ausgleich für numerische Ungenauigkeit)
    qD_korr = J_x(I_EE,:) \ xD_korr;
    % zu xD passende Gelenk-Geschw. für diesen Zeitschritt (k)
    qD_k = qD_k_T + qDNk0 + qD_korr;
    % Debug: 
    % Korrigiere nachträglich auch die Beschleunigung, da sie sich geändert
    % hat. Benutze direkt den Differenzenquotienten. Sonst inkonsistente Ausgabe.
    % Nehme Quotienten in dem die Korrektur der Position berücksichtigt ist.
    % TODO: Noch keine gute Lösung. Vermutlich Problem große Schrittweite.
    % if k > 1
    %   QDD(k-1,:) = 1/dt^2*(Q(k,:) - Q(k-1,:) - QD(k-1,:)*dt);
    % end
  end
  %% Gelenk-Beschleunigung berechnen
  if ~simplify_acc
    % Zeitableitung der geometrischen Jacobi-Matrix (siehe [1]).
    JgD = %RN%_jacobigD_sym_varpar(q_k, qD_k, link_index, r_i_i_C, pkin);
    % Zeitableitung der Euler-Transformationsmatrix
    TDw = euljacD(X(k,4:6)', XD(k,4:6)', s.phiconv_W_E);
    % Zeitableitung der inversen Euler-Transformationsmatrix
    TwD_inv = -Tw\TDw/Tw;
    % Zeitableitung der analytischen Jacobi (Rotationsteil "e")
    JeD = Tw\JgD(4:6,:) + TwD_inv *Jg(4:6,:);
    % Zeitableitung analytische Jacobi komplett
    JD_x = [JgD(1:3,:); JeD];
  else
    % Annäherung der Jacobi-Zeitableitung durch den linken Differenzen-
    % quotienten der Jacobi-Matrix. Für ersten Zeitschritt ist der Wert
    % hier grob falsch. Annahme: Geschwindigkeit im ersten Zeitschritt
    % immer Null. Daher kein Einfluss. Funktioniert nur bei Rast-Rast-
    % Trajektorien. dt ist die Zeit zum nächsten Schritt. Annahme:
    % Äquidistant.
    JD_x = (J_x-J_x_alt)/dt;
  end
  % Gelenk-Beschleunigung mit inverser Jacobi (bzw. Pseudo-Inv.) berechnen
  % Siehe z.B. [RMG16]/(19)
  if s.ik_solution_min_norm
    % Pseudo-Inverse: Minimale Norm des Vektors
    qDD_k_T(:) = J_x(I_EE,:) \ (XDD(k,I_EE)' - JD_x(I_EE,:)*qD_k);
  else
    % Normale Inverse. Nehme die Beschleunigung aus XDD an. Damit auch Vor-
    % steuerung einer Nullraumbeschleunigung möglich
    qDD_k_T(:) = J_x(Rob_I_EE,:) \ (XDD(k,Rob_I_EE)' - JD_x(Rob_I_EE,:)*qD_k);
  end
  % Setze die Grenzen für qDD_N basierend auf gegebenen Grenzen für 
  % gesamte Beschleunigung und notwendige Beschleunigung qDD_T
  qDD_N_min = qDDmin - qDD_k_T;
  qDD_N_max = qDDmax - qDD_k_T;
  % Nullraumbewegung auf Beschleunigungsebene berechnen. Siehe [RMG16]
  if nsoptim || redundant
    % Nullraum-Projektor
    N = (eye(NQJ) - pinv(J_x(I_EE,:))*J_x(I_EE,:));
    % Berechne Maximalgeschwindigkeit für Nullraumbewegung für den nächsten
    % Zeitschritt. Unten wird dies für den nächsten Zeitschritt benutzt.
    if ~isempty(s.nullspace_maxvel_interp) && k < nt
      vmax_rel = interp1(s.nullspace_maxvel_interp(1,:), ... % Zeit-Stützstellen
        s.nullspace_maxvel_interp(2,:), T(k+1)); % Werte für vrel, Wahl für Zeitpunkt
      phizD_N_lim_noscale = s.xDlim(6,:) - xD_k_T_ist(6);
      if vmax_rel == 1 % Halte die relative Geschw. bzgl. der Grenzen fest
        % Aufschlag von 50%, damit das Bremsen der Nullraumbewegung lang-
        % samer passiert. Zuerst Prüfung der EE-Drehung (Nullraum)
        vmax_rel_lastvel = 1.5*max((xD_k_ist(6)- xD_k_T_ist(6)) ./ s.xDlim(6,:));
        % Anschließend Prüfung der Gelenkgeschwindigkeit (Nullraum)
        vmax_rel_lastvel = max(vmax_rel_lastvel, 1.5*max(max(repmat(qD_k-qD_k_T,1,2)./s.qDlim)));
        % Skalierung darf höchstens eins sein (falls vorher über Grenzen)
        vmax_rel_lastvel = min(vmax_rel_lastvel, 1);
      else
        % Abbremsen der Nullraumbewegung. Benutze den vorher festgehaltenen
        % Maximalwert der tatsächlichen Geschwindigkeit als Basis zum
        % Abbremsen. Dadurch sofort Abbremsen und nicht erst bei kleinen
        % Geschwindigkeiten relativ spät.
        vmax_rel = vmax_rel_lastvel * vmax_rel;
      end
      phizD_N_lim = phizD_N_lim_noscale * vmax_rel;
      % Setze die Grenzen für die Gelenkgeschwindigkeit basierend auf der
      % skalierten Nullraumgeschwindigkeit
      qD_N_lim_noscale = s.qDlim - repmat(qD_k_T,1,2);
      qD_N_lim = qD_N_lim_noscale * vmax_rel;
    end
    % Bestimme Grenzen für redundante Koordinate per Interpolation
    % Dadurch ist eine Aufweitung und Verengung der Grenzen möglich.
    % Die Grenzen beziehen sich weiterhin auf die Trajektorie X
    if ~isempty(s.xlim6_interp)
      xlim(6,:) = [interp1(s.xlim6_interp(1,:), s.xlim6_interp(2,:), T(k), 'spline'), ...
              interp1(s.xlim6_interp(1,:), s.xlim6_interp(3,:), T(k), 'spline')];
      % Bestimme Grenze für x6 dynamisch aus dem Bremsweg bis zur Grenze.
      % Nehme den 1.2-fachen Bremsweg, da zunächst nur schwach gebremst wird
      delta_phiz = 1.2 * 0.5 * s.xDlim(6,2)^2/s.xDDlim(6,2);
      xlim_thr_h10 = xlim;
      % Benutze den Bremsweg für die Aktivierungsschwelle. Dadurch
      % langsame (stetige) Aktivierung der Funktion etwas mit berücksichtigt.
      xlim_thr_h10(6,:) = xlim_thr_h10(6,:) + [+1, -1]*delta_phiz;
      if xlim_thr_h10(6,1) > xlim_thr_h10(6,2)
        % Wenn min und max vertauscht sind, ist der Bremsweg zu groß. Immer
        % aktivieren
        xlim_thr_h10(6,:) = 0;
      end
%       xlim_thr_h10 = repmat(mean(xlim,2),1,2) + repmat(xlim(:,2)-xlim(:,1),1,2).*...
%         repmat([-0.5, +0.5]*0.8,6,1); % vorläufig auf 80% der Grenzen in xlim
    end
  end
  if nsoptim || ...% Nullraumbewegung, siehe [RMG16], [RMG18]
      calc_h_nored % Leistungsmerkmale sollen im nicht-redundanten Fall berechnet werden
    % Positions-bezogene Kriterien werden auf Geschwindigkeitsebene behandelt
    % Geschwindigkeits-bezogene Kennzahlen werden auf Beschleunigungsebene behandelt
    v_qD = zeros(NQJ, 1);
    v_qDD = zeros(NQJ, 1);
    %% Einhaltung der Gelenkwinkel-Grenzen
    if wn(idx_wnP.qlim_par) ~= 0 || wn(idx_wnD.qlim_par) ~= 0 % Quadratischer Abstand von Gelenkgrenzen
      [h(idx_hn.qlim_par), h1dq] = invkin_optimcrit_limits1(q_k, qlim);
      v_qD = v_qD - wn(idx_wnD.qlim_par)*h1dq';
      v_qDD = v_qDD - wn(idx_wnP.qlim_par)*h1dq';
    end
    if wn(idx_wnP.qlim_hyp) ~= 0 || wn(idx_wnD.qlim_hyp) ~= 0 % Hyperbolischer Abstand von Gelenkgrenzen
      [h(idx_hn.qlim_hyp), h2dq] = invkin_optimcrit_limits2(q_k, qlim, qlim_thr_h2);
      v_qD = v_qD - wn(idx_wnD.qlim_hyp)*h2dq';
      v_qDD = v_qDD - wn(idx_wnP.qlim_hyp)*h2dq';
    end
    if wn(idx_wnP.qDlim_par) ~= 0 % Quadratischer Abstand von Gelenkgeschwindigkeitsgrenzen
      % Entspricht Dämpfungsterm DeLucaOriSic1992
      [h(idx_hn.qDlim_par), h3dq] = invkin_optimcrit_limits1(qD_k, qDlim);
      v_qDD = v_qDD - wn(idx_wnP.qDlim_par)*h3dq';
    end
    if wn(idx_wnP.qDlim_hyp) ~= 0
      [h(idx_hn.qDlim_hyp), h4dq] = invkin_optimcrit_limits2(qD_k, qDlim);
      v_qDD = v_qDD - wn(idx_wnP.qDlim_hyp)*h4dq';
    end
    %% Singularitätsvermeidung IK-Jacobi-Matrix (Aufgaben-FG) und geom. Jacobi-Matrix (Roboter-FG)
    if (wn(idx_wnP.ikjac_cond) ~= 0 || wn(idx_wnD.ikjac_cond) ~= 0) && condJik > s.cond_thresh_ikjac || ... % IK-Jacobi-Matrix (Aufgaben-FG)
       (wn(idx_wnP.jac_cond) ~= 0 || wn(idx_wnD.jac_cond) ~= 0) && condJ > s.cond_thresh_jac || ...% geom. Jacobi-Matrix (Roboter-FG)
        wn(idx_wnP.poserr_ee) ~= 0 % Positionsfehler ist ähnlich
      h(idx_hn.ikjac_cond) = invkin_optimcrit_condsplineact(condJik, ... %  Konditionszahl
          1.5*s.cond_thresh_jac, s.cond_thresh_ikjac); % mit Spline-Aktivierung
      h(idx_hn.jac_cond) = invkin_optimcrit_condsplineact(condJ, ... %  Konditionszahl
          1.5*s.cond_thresh_jac, s.cond_thresh_jac); % mit Spline-Aktivierung
      h(idx_hn.poserr_ee) = max(abs(Jg(1:3,:)) * s.q_poserr);
      if nsoptim
      if NQJ - sum(I_EE) == 1 && ~I_EE(end)
        % Redundanz ist reine Aufgabenredundanz mit Rotationssymmetrie
        % Numerischer Differenzenquotient aus Bewegung in EE-z-Drehung.
        xD_test = [zeros(5,1);1e-6];
        qD_test = J_x\xD_test;
        Jg_test = %RN%_jacobig_sym_varpar(q_k+qD_test, link_index, r_i_i_C, pkin);
        J_x_test = [Jg_test(1:3,:); Tw \ Jg_test(4:6,:)]; % analytische Jacobi-Matrix
        h5test = invkin_optimcrit_condsplineact(cond(J_x_test(I_EE,:)), ...
          1.5*s.cond_thresh_jac, s.cond_thresh_ikjac);
        h6test = invkin_optimcrit_condsplineact(cond(Jg_test(Rob_I_EE,:)), ...
          1.5*s.cond_thresh_jac, s.cond_thresh_jac);
        h24test = max(abs(Jg_test(1:3,:)) * s.q_poserr);
        % Gradient bezüglich Redundanz-FG (letzter Euler-Winkel)
        h5drz = (h5test-h(idx_hn.ikjac_cond))/1e-6;
        h6drz = (h6test-h(idx_hn.jac_cond))/1e-6;
        h24drz = (h24test-h(idx_hn.poserr_ee))/1e-6;
        % Umrechnung auf Gelenke mit Jacobi-Matrix
        h5dq = h5drz*J_x(end,:);
        h6dq = h6drz*J_x(end,:);
        h24dq = h24drz*J_x(end,:);
      else
        % Allgemeiner Fall von Redundanz (nicht nur Drehung um die zE-Achse)
        % Bilde Differenzenquotient in allen Gelenkachsen
        if any(abs(q_k-q_wn5) > 3*pi/180) % seltenere Berechnung (Rechenzeit)
          for kkk = 1:NQJ % Differenzenquotient für jede Gelenkkoordinate
            q_test = q_k; % ausgehend von aktueller Konfiguration
            q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
            Jg_kkk = %RN%_jacobig_sym_varpar(q_test, link_index, r_i_i_C, pkin); % geometrische Jacobi-Matrix
            J_x_kkk_voll = [Jg_kkk(1:3,:); Tw \ Jg_kkk(4:6,:)]; % analytische Jacobi-Matrix
            h5_kkk = invkin_optimcrit_condsplineact(cond(J_x_kkk_voll(I_EE,:)), ...
              1.5*s.cond_thresh_ikjac, s.cond_thresh_ikjac);
            h6_kkk = invkin_optimcrit_condsplineact(cond(Jg_kkk(Rob_I_EE,:)), ...
              1.5*s.cond_thresh_jac, s.cond_thresh_jac);
            h5dq(kkk) = (h5_kkk-h(idx_hn.ikjac_cond))/1e-6;
            h6dq(kkk) = (h6_kkk-h(idx_hn.jac_cond))/1e-6;
            h24dq(kkk) = (max(abs(Jg_kkk(1:3,:)) * s.q_poserr)-h(idx_hn.poserr_ee))/1e-6;
          end
          q_wn5 = q_k;
        end
      end
      v_qD = v_qD - wn(idx_wnD.ikjac_cond)*h5dq';
      v_qDD = v_qDD - wn(idx_wnP.ikjac_cond)*h5dq';
      v_qD = v_qD - wn(idx_wnD.jac_cond)*h6dq';
      v_qDD = v_qDD - wn(idx_wnP.jac_cond)*h6dq';
      v_qD = v_qD - wn(idx_wnD.poserr_ee)*h24dq';
      v_qDD = v_qDD - wn(idx_wnP.poserr_ee)*h24dq';
      end % if nsoptim
    else
      h(idx_hn.jac_cond) = 0; % Wenn Schwellwert nicht überschritten, Wert auf Null setzen
    end
    
    %% Kollisionsvermeidung
    if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp,idx_wnP.coll_par,idx_wnD.coll_par]) ~= 0) % Kollisionsvermeidung bzw. Kollisionsabstand
      % Prüfe ob eine Kollision vorliegt (bei den vergrößerten Koll.-Körpern)
      colldet_warn = false;
      colldet = true(1, size(s.collchecks,1)); % Für Kompilierbarkeit
      if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp])~=0)
        colldet = check_collisionset_simplegeom(collbodies_ns, s.collchecks, ...
          Tc_stack_k(:,4)', struct('collsearch', true));
        if any(colldet)
          colldet_warn = true;
        end
      end
      if any(wn([idx_wnP.coll_par,idx_wnD.coll_par])) && ~colldet_warn
        % Prüfe im Folgenden Schritt alle Kollisionen
        colldet(:) = true;
      end
      h([idx_hn.coll_hyp,idx_hn.coll_par]) = 0; h7dq(:) = 0; h13dq(:) = 0;
      if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp]) ~= 0) && colldet_warn || ...
         any(wn([idx_wnP.coll_par,idx_wnD.coll_par]) ~= 0)
        % Kollision im Warnbereich erkannt. Prüfe Abstände bzw.
        % Eindringtiefen und erzeuge Bewegung von Kollision weg.
        if NQJ - sum(I_EE) == 1 && ~I_EE(end)
          % Gelenkpositionen für Kollisionsprüfung bilden
          JP_test = NaN(1+1,size(Tc_stack_k,1));
          JP_test(1,:) = Tc_stack_k(:,4)';
          % Redundanz ist reine Aufgabenredundanz mit Rotationssymmetrie
          % Numerischer Differenzenquotient aus Bewegung in EE-z-Drehung.
          xD_test = [zeros(5,1);1e-6];
          qD_test = J_x\xD_test;
          Tc_stack_test = %RN%_fkine_coll(q_k+qD_test, pkin, s.T_N_E, link_index);
          JP_test(1+1,:) = Tc_stack_test(:,4);
          % Kollisionsprüfung für alle Gelenkpositionen auf einmal. Prüfe
          % nur die Fälle, bei denen die vergrößerten Objekte bereits eine
          % Kollision angezeigt haben.
          [~, colldist_test] = check_collisionset_simplegeom( ...
            s.collbodies, s.collchecks(colldet,:), JP_test, struct('collsearch', false));
          % Prüfe, welche Kollisionsprüfungen durch die Gelenkbewegung
          % beeinflusst werden
          I_nochange = abs(colldist_test(1,:)-colldist_test(2,:)) < 1e-12;
          if all(I_nochange) % Keine Kollision nennenswert geändert
            % Setze alle auf exakt den gleichen Wert. Dann Gradient Null.
            mincolldist_test = repmat(colldist_test(1), size(colldist_test,1),1);
          else % Normale Bestimmung der Abstände möglich
            % Benutze nur die zur Bildung des Gradienten
            mincolldist_test = min(colldist_test(:,~I_nochange),[],2); % Schlimmste Kollision für jeden Körper bestimmen
          end
          if colldet_warn % nur im Warnbereich aktiv
            h(idx_hn.coll_hyp) = invkin_optimcrit_limits3(-mincolldist_test(1), ...
              [-5*collobjdist_thresh, 0], -collobjdist_thresh);
          else
            h(idx_hn.coll_hyp) = 0;
          end
          if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp]) ~= 0) % hyperbolisches Kriterium
            if h(idx_hn.coll_hyp) == 0 || ... % nichts tun. Noch im Toleranzbereich
              all(I_nochange) % Kein Gradient bestimmbar
              h7drz = 0;
            elseif ~isinf(h(idx_hn.coll_hyp))
              h7_test = invkin_optimcrit_limits3(-mincolldist_test(2), ...
                [-5*collobjdist_thresh, 0], -collobjdist_thresh);
              % Gradient bezüglich Redundanz-FG (letzter Euler-Winkel)
              h7drz = (h7_test - h(idx_hn.coll_hyp))/1e-6;
            else % Kollision so groß, dass Wert inf ist. Dann kein Gradient aus h bestimmbar.
              % Indirekte Bestimmung über die betragsmäßige Verkleinerung der (negativen) Eindringtiefe
              h7drz = (-mincolldist_test(2)-(-mincolldist_test(1)));
              if abs(h7drz) > 100*eps % Normiere auf Wert 1e3
                h7drz = sign(h7drz) * 1e3; % wird weiter unten reduziert (für qDD_max)
              end
            end
            % Umrechnung auf Gelenke mit Jacobi-Matrix
            h7dq = h7drz*J_x(end,:);
          end
          h(idx_hn.coll_par) = invkin_optimcrit_limits1(-mincolldist_test(1), ...
            [-10*maxcolldepth, 0]); % ist immer aktiv
          if any(wn([idx_wnP.coll_par,idx_wnD.coll_par]) ~= 0) && ~all(I_nochange) % quadratisches Kriterium
            h13_test = invkin_optimcrit_limits1(-mincolldist_test(2), ...
              [-10*maxcolldepth, 0]);
            h13drz = (h13_test - h(idx_hn.coll_par))/1e-6;
            h13dq = h13drz*J_x(end,:);
          else
            h13dq(:) = 0;
          end
        else
          % Allgemeiner Fall von Redundanz (nicht nur Drehung um die zE-Achse)
          % Bilde Differenzenquotient in allen Gelenkachsen (siehe oben)
          JP_test = NaN(1+NQJ,size(Tc_stack_k,1));
          JP_test(1,:) = Tc_stack_k(:,4)';
          for kkk = 1:NQJ % Differenzenquotient für jede Gelenkkoordinate
            q_test = q_k; % ausgehend von aktueller Konfiguration
            q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
            Tc_stack_kkk = %RN%_fkine_coll(q_test, pkin, s.T_N_E, link_index);
            JP_test(1+kkk,:) = Tc_stack_kkk(:,4); % Letzte Spalte der homog. Trafo.-Matrix
          end
          % Kollisionsprüfung für alle Gelenkpositionen auf einmal
          [~, colldist_test] = check_collisionset_simplegeom( ...
            s.collbodies, s.collchecks(colldet,:), JP_test, struct('collsearch', false));
          I_nochange = abs(diff(minmax2(colldist_test')')) < 1e-12;
          if all(I_nochange) % Keine Kollision nennenswert geändert
            % Setze alle auf exakt den gleichen Wert. Dann Gradient Null.
            mincolldist_test = repmat(colldist_test(1), size(colldist_test,1),1);
          else % Normale Bestimmung der Abstände möglich
            % Benutze nur die zur Bildung des Gradienten
            mincolldist_test = min(colldist_test,[],2); % Schlimmste Kollision für jeden Körper bestimmen
          end
          if colldet_warn % aktiv im Warnbereich
            h(idx_hn.coll_hyp) = invkin_optimcrit_limits3(-mincolldist_test(1), ...
              [-5*collobjdist_thresh, 0], -collobjdist_thresh);
          else
            h(idx_hn.coll_hyp) = 0;
          end
          if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp]) ~= 0) && colldet_warn % hyperbolisches Kriterium
            if h(idx_hn.coll_hyp) == 0 || all(I_nochange) % nichts tun. Noch im Toleranzbereich
              h7dq(:) = 0;
            elseif ~isinf(h(idx_hn.coll_hyp))
              for kkk = 1:NQJ
                % Kriterium für Inkrement berechnen
                h7_test = invkin_optimcrit_limits3(-mincolldist_test(1+kkk), ...
                  [-5*collobjdist_thresh, 0], -collobjdist_thresh);
                % Differenzenquotient
                h7dq(kkk) = (h7_test'-h(idx_hn.coll_hyp))/1e-6;
              end
            else % Kollision so groß, dass Wert inf ist. Dann kein Gradient aus h bestimmbar.
              % Indirekte Bestimmung über die betragsmäßige Verkleinerung der (negativen) Eindringtiefe
              for kkk = 1:NQJ
                h7dq(kkk) = (-mincolldist_test(1+kkk)-(-mincolldist_test(1)));
              end
              if max(abs(h7dq)) > 100*eps % Normiere auf Wert 1e3 für größtes Gelenk
                h7dq = h7dq/max(abs(h7dq)) * 1e3; % wird weiter unten reduziert (für qDD_max)
              end
            end
          end
          h(idx_hn.coll_par) = invkin_optimcrit_limits1(-mincolldist_test(1), ...
            [-10*maxcolldepth, 0]);
          if any(wn([idx_wnP.coll_par,idx_wnD.coll_par]) ~= 0) && ~all(I_nochange) % quadratisches Kriterium
            for kkk = 1:NQJ
              % Kriterium für Inkrement berechnen
              h13_test = invkin_optimcrit_limits1(-mincolldist_test(1+kkk), ...
                [-10*maxcolldepth, 0]);
              % Differenzenquotient
              h13dq(kkk) = (h13_test'-h(idx_hn.coll_par))/1e-6;
            end
          else
            h13dq(:) = 0;
          end
        end
        if any(wn([idx_wnP.coll_hyp,idx_wnD.coll_hyp]) ~= 0) % hyperbolisches Kriterium
          v_qD = v_qD - wn(idx_wnD.coll_hyp)*h7dq';
          v_qDD = v_qDD - wn(idx_wnP.coll_hyp)*h7dq';
        end
        if any(wn([idx_wnP.coll_par,idx_wnD.coll_par]) ~= 0) % quadratisches Kriterium
          v_qD = v_qD - wn(idx_wnD.coll_par)*h13dq';
          v_qDD = v_qDD - wn(idx_wnP.coll_par)*h13dq';
        end
      else
        h(idx_hn.coll_hyp) = 0;
      end
    end
    %% Einhaltung der Bauraum-Grenzen
    h([idx_hn.instspc_hyp, idx_hn.instspc_par]) = 0;
    if wn(idx_wnP.instspc_hyp) ~= 0 || wn(idx_wnD.instspc_hyp) ~= 0 || ... % Bauraumprüfung
       wn(idx_wnP.instspc_par) ~= 0 || wn(idx_wnD.instspc_par) ~= 0 
      if NQJ - sum(I_EE) == 1 && ~I_EE(end) % Aufgabenredundanz
        % Gelenkpositionen für Kollisionsprüfung bilden
        JP_test = NaN(1+1,size(Tc_stack_k,1));
        JP_test(1,:) = Tc_stack_k(:,4)';
        % Redundanz ist reine Aufgabenredundanz mit Rotationssymmetrie
        % Numerischer Differenzenquotient aus Bewegung in EE-z-Drehung.
        xD_test = [zeros(5,1);1e-6];
        qD_test = J_x\xD_test;
        Tc_stack_test = %RN%_fkine_coll(q_k+qD_test, pkin, s.T_N_E, link_index);
        JP_test(1+1,:) = Tc_stack_test(:,4);
        [~, absdist] = check_collisionset_simplegeom(s.collbodies_instspc, ...
          s.collchecks_instspc, JP_test, struct('collsearch', false));
        I_nochange = abs(absdist(1,:)-absdist(2,:)) < 1e-12;
        if all(I_nochange) % Keine Bauraumprüfung nennenswert geändert
          % Setze alle auf exakt den gleichen Wert. Dann Gradient Null.
          mindist_all = repmat(absdist(1), size(JP_test,1),1);
        else
          % Prüfe, ob alle beweglichen Kollisionsobjekte in mindestens einem
          % Bauraumkörper enthalten sind (falls Prüfung gefordert)
          mindist_all = -inf(size(JP_test,1),1);
          for i = 1:size(s.collbodies_instspc.link,1)
            % Indizes aller Kollisionsprüfungen mit diesem (Roboter-)Objekt j
            I = s.collchecks_instspc(:,1) == i & ... % erste Spalte für Roboter-Obj.
                ~I_nochange'; % Nur solche Objektprüfungen berücksichtigen, die hier beeinflusst werden
            if ~any(I), continue; end % Bauraum-Objekte nicht direkt prüfen. Sonst leeres Array
            % Falls mehrere Bauraum-Objekte, nehme das mit dem besten Wert
            mindist_i = min(absdist(:,I),[],2);
            % Nehme den schlechtesten Wert von allen Objekten
            mindist_all = max([mindist_i,mindist_all],[],2);
          end
        end
        % Bauraum-Kriterium berechnen: Negativer Wert ist im Bauraum (gut),
        % positiver ist außerhalb (schlecht). Größter positiver Wert
        % maßgeblich
        if wn(idx_wnP.instspc_hyp) ~= 0 || wn(idx_wnD.instspc_hyp) ~= 0 % hyperbolisch
          h(idx_hn.instspc_hyp) = invkin_optimcrit_limits3(mindist_all(1), ... % Wert bezogen auf aktuelle Pose
            [-100.0, 0], ... % obere Grenze: Bei Überschreitung des Bauraums ist Wert inf
            -s.installspace_thresh); % obere Grenze: z.B. ab 100mm Nähe zum Rand Kriterium aktiv
          if h(idx_hn.instspc_hyp) == 0 || ...% nichts unternehmen (im Bauraum, mit Sicherheitsabstand)
            all(I_nochange) % Kein Gradient bestimmbar
            h8drz = 0;
          elseif ~isinf(h(idx_hn.instspc_hyp))
            h8_test = invkin_optimcrit_limits3(mindist_all(2), ... % Wert bezogen auf Test-Pose
              [-100.0, 0], -s.installspace_thresh);
            % Gradient bezüglich Redundanz-FG (letzter Euler-Winkel)
            h8drz = (h8_test - h(idx_hn.instspc_hyp))/1e-6;
          else % Verletzung so groß, dass Wert inf ist. Dann kein Gradient aus h bestimmbar.
            % Indirekte Bestimmung über die Verkleinerung des (positiven) Abstands
            h8drz = (mindist_all(2)-mindist_all(1));
            if abs(h8drz) > 100*eps % Normiere auf Wert 1e3 für größtes Gelenk
              h8drz = sign(h8drz) * 1e3; % wird weiter unten reduziert
            end
          end
          % Umrechnung auf Gelenke mit Jacobi-Matrix
          h8dq = h8drz*J_x(end,:);
        end
        if wn(idx_wnP.instspc_par) ~= 0 || wn(idx_wnD.instspc_par) ~= 0 % quadratisch
          h(idx_hn.instspc_par) = invkin_optimcrit_limits1(mindist_all(1), ...
            [-100.0, 0]); % Quadratisch bezogen auf -50m als Mitte. Dadurch immer auf rechtem Parabel-Ast
          if all(I_nochange) % Kein Gradient bestimmbar
            h13drz = 0;
          else
            h13_test = invkin_optimcrit_limits1(mindist_all(2),[-100,0]);
            % Gradient bezüglich Redundanz-FG (letzter Euler-Winkel)
            h13drz = (h13_test - h(idx_hn.instspc_par))/1e-6;
          end
          h13dq = h13drz*J_x(end,:); % Umrechnung auf Gelenke mit Jacobi-Matrix
        end
      else
        % Allgemeiner Fall von Redundanz (nicht nur Drehung um die zE-Achse)
        % Bilde Differenzenquotient in allen Gelenkachsen (siehe oben)
        JP_test = NaN(1+NQJ,size(Tc_stack_k,1));
        JP_test(1,:) = Tc_stack_k(:,4)';
        for kkk = 1:NQJ % Differenzenquotient für jede Gelenkkoordinate
          q_test = q_k; % ausgehend von aktueller Konfiguration
          q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
          Tc_stack_kkk = %RN%_fkine_coll(q_test, pkin, s.T_N_E, link_index);
          JP_test(1+kkk,:) = Tc_stack_kkk(:,4); % Letzte Spalte der homog. Trafo.-Matrix
        end
        % Kollisionsprüfung für alle Gelenkpositionen auf einmal
        [~, absdist] = check_collisionset_simplegeom(s.collbodies_instspc, ...
          s.collchecks_instspc, JP_test, struct('collsearch', false));
        mindist_all = -inf(size(JP_test,1),1);
        for i = 1:size(s.collbodies_instspc.link,1)
          I = s.collchecks_instspc(:,1) == i;
          if ~any(I), continue; end
          mindist_i = min(absdist(:,I),[],2);
          mindist_all = max([mindist_i,mindist_all],[],2);
        end
        if wn(idx_wnP.instspc_hyp) ~= 0 || wn(idx_wnD.instspc_hyp) ~= 0 % hyperbolisch
          h(idx_hn.instspc_hyp) = invkin_optimcrit_limits3(mindist_all(1), ... % Wert bezogen auf aktuelle Pose
            [-100.0, 0], -s.installspace_thresh);
          if h(idx_hn.instspc_hyp) == 0 % nichts unternehmen (im Bauraum, mit Sicherheitsabstand)
            h8dq(:) = 0;
          elseif ~isinf(h(idx_hn.instspc_hyp))
            for kkk = 1:NQJ
              % Kriterium für Inkrement berechnen
              h8_test = invkin_optimcrit_limits3(mindist_all(1+kkk), ... % Wert bezogen auf Test-Pose
                [-100.0, 0], -s.installspace_thresh);
              % Differenzenquotient
              h8dq(kkk) = (h8_test'-h(idx_hn.instspc_hyp))/1e-6;
            end
          else % Verletzung so groß, dass Wert inf ist. Dann kein Gradient aus h bestimmbar.
            % Indirekte Bestimmung über die Verkleinerung des (positiven) Abstands
            for kkk = 1:NQJ
              h8dq(kkk) = (mindist_all(1+kkk)-mindist_all(1));
            end
            if max(abs(h8dq)) > 100*eps % Normiere auf Wert 1e3 für größtes Gelenk
              h8dq = h8dq/max(abs(h8dq)) * 1e3; % wird weiter unten reduziert (bei qDD)
            end
          end
        end
        if wn(idx_wnP.instspc_par) ~= 0 || wn(idx_wnD.instspc_par) ~= 0 % quadratisch
          for kkk = 1:NQJ
            % Kriterium für Inkrement berechnen
            h13_test = invkin_optimcrit_limits1(mindist_all(1+kkk),[-100,0]);
            % Differenzenquotient
            h13dq(kkk) = (h13_test'-h(idx_hn.instspc_par))/1e-6;
          end
        end
      end
      if wn(idx_wnP.instspc_hyp) ~= 0 || wn(idx_wnD.instspc_hyp) ~= 0
        v_qD = v_qD - wn(idx_wnD.instspc_hyp)*h8dq';
        v_qDD = v_qDD - wn(idx_wnP.instspc_hyp)*h8dq';
      end
      if wn(idx_wnP.instspc_par) ~= 0 || wn(idx_wnD.instspc_par) ~= 0
        v_qD = v_qD - wn(idx_wnD.instspc_par)*h13dq';
        v_qDD = v_qDD - wn(idx_wnP.instspc_par)*h13dq';
      end
    end
    %% Einhaltung der Grenzen der redundanten Koordinate
    delta_phi_z = NaN;
    if any(wn([idx_wnP.xlim_par, idx_wnD.xlim_par, idx_wnP.xDlim_par, ...
        idx_wnP.xlim_hyp,idx_wnD.xlim_hyp]))
      % Bestimme Ist-Lage des Endeffektors (xD_k_ist bereits oben bestimmt).
      x_k_ist = x_k; % Vorbelegen der nicht redundanten Koordinaten
      % Das IK-Residuum bezieht sich auf x_k und bildet die Differenz des
      % Ist-Werts zum Referenz-Wert x_k(6) aus der Trajektorie
      delta_phi_z = -Phi_k_voll(4); % phiz_soll - phiz_ist
      if k == 1 % erster Zeitschritt. Kein Wert außerhalb 180° vorgesehen
        x_k_ist(6) = x_k(6) - delta_phi_z; % z-Komponente der ZB
      else % folgende Zeitschritte: Euler-Einschritt-Integration von phi_z
        % Siehe denormalize_angle_traj Exakte Berechnung in Phi_k_voll(4) wird um
        % 2pi verschoben basierend auf Integration mit Geschwindigkeit
        x_k_ist(6) = normalizeAngle(x_k(6) - delta_phi_z, X(k-1,6)+xD_k_ist(6)*dt);
      end
      X(k,6) = x_k_ist(6); % In Eingabe speichern, um Integration durchzuführen
    end
    if wn(idx_wnP.xlim_par) ~= 0 || wn(idx_wnD.xlim_par) ~= 0 % Quadr. Abstand von Phi bzgl. redundantem FHG von xlim maximieren
      [h(idx_hn.xlim_par), h9drz] = invkin_optimcrit_limits1(-delta_phi_z, xlim(6,1:2));
      h9dq = h9drz*J_x(end,:); % Siehe [SchapplerOrt2021], Gl. 14
      v_qD  = v_qD  - wn(idx_wnD.xlim_par)*h9dq'; % D-Anteil (auf qDD)
      v_qDD = v_qDD - wn(idx_wnP.xlim_par)*h9dq'; % P-Anteil (auf qDD)
    end
    if wn(idx_wnP.xlim_hyp) ~= 0 || wn(idx_wnD.xlim_hyp) ~= 0 % Hyperb. Abstand außerhalb von xlim minimieren
      % Kriterium für aktuellen Schritt
      [h(idx_hn.xlim_hyp), h10drz] = invkin_optimcrit_limits2(-delta_phi_z, ...
        xlim(6,1:2), xlim_thr_h10(6,:));
      h10dq = h10drz*J_x(end,:); % Siehe [SchapplerOrt2021], Gl. 14
      v_qD  = v_qD  - wn(idx_wnD.xlim_hyp)*h10dq'; % D-Anteil (auf qDD)
      v_qDD = v_qDD - wn(idx_wnP.xlim_hyp)*h10dq'; % P-Anteil (auf qDD)
    end
    if wn(idx_wnP.xDlim_par) ~= 0 % Quadr. Abstand von phiD bzgl. redundantem FHG von xDlim minimieren
      % Kriterium für aktuellen Schritt
      XD6_k_diff = xD_k_ist(6) - XD(k,6); % Geschwindigkeit von phi_z für Iterationsschritt
      [h(idx_hn.xDlim_par), h11drz] = invkin_optimcrit_limits1(XD6_k_diff, s.xDlim(6,1:2));
      h11dq = h11drz*J_x(end,:); % Siehe [SchapplerOrt2021], Gl. 14
      v_qDD = v_qDD - wn(idx_wnP.xDlim_par)*h11dq';
    end
    %% Nullraumbewegung abschließen
    if nsoptim
    % Begrenze die Werte für die Gradienten (können direkt an Grenzen
    % oder Singularitäten extrem werden). Dann Numerik-Fehler und keine
    % saubere Nullraumbewegung mehr möglich.
    if any(abs(v_qD)>1e3),  v_qD  = v_qD* 1e3/max(abs(v_qD));  end
    if any(abs(v_qDD)>1e6), v_qDD = v_qDD*1e6/max(abs(v_qDD)); end
    % Berechne die Nullraumbewegung im Gelenkraum aus den Gradienten
    % Nullraum-Geschwindigkeit; [RMG18], Gl. 11
    qD_N_pre = N * v_qD;
    % Berechne die Nullraum-Beschleunigung durch Zeitableitung. [RMG18], Remark 4.
    % Benutze Differenzenquotient anstatt der analytischen Ableitungen in [RMG18]
    qDD_N_pre1 = N*(qD_N_pre-qD_N_pre_alt)/dt;
    % Speichere den Altwert für den Differenzenquotienten
    qD_N_pre_alt = qD_N_pre;
    % Erster Wert ("pre") für Beschleunigung durch Minimierung der
    % Zielfunktion h. Siehe [RMG16]/(20) (zweiter Term)
    % Hier auch direkte Addition der Nullraumbewegung aus Geschwindigkeit.
    qDD_N_pre = qDD_N_pre1 + N * v_qDD;
    end
  else
    qDD_N_pre = zeros(NQJ,1);
  end
  
  % Reduziere die Nullraumbeschleunigung weiter, falls Beschleunigungs-
  % Grenzen erreicht werden. Sollte eigentlich nur hier gemacht werden,
  % wird aber zur Verbesserung der Robustheit auch zusätzlich noch unten
  % gemacht. Hat unten zur Folge, dass Verletzung von Positions- und
  % Geschwindigkeitsgrenzen nicht mit allen Mitteln verhindert werden
  if redundant && limits_qDD_set
    delta_ul_rel = (qDD_N_max - qDD_N_pre)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
    delta_ll_rel = (-qDD_N_min + qDD_N_pre)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
    if any([delta_ul_rel;delta_ll_rel] < 0)
      if min(delta_ul_rel)<min(delta_ll_rel)
        % Verletzung nach oben ist die größere
        [~,I_max] = min(delta_ul_rel);
        scale = (qDD_N_max(I_max))/(qDD_N_pre(I_max));
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_min] = min(delta_ll_rel);
        scale = (qDD_N_min(I_min))/(qDD_N_pre(I_min));
      end
      qDD_N_pre = scale*qDD_N_pre;
    end
  end
  
  % Reduziere die Nullraumbeschleunigung im Gelenkraum, falls Grenzen für
  % Beschleunigung der redundanten Endeffektor-Koordinaten verletzt werden
  if NQJ - sum(I_EE) == 1 && ~I_EE(end) && limits_xDD_set
    % Berechne Ist-x-Beschleunigung aufgrund aktueller q-Beschleunigung
    xDD_JDqD = JD_x * qD_k; % Diesen Term weglassen, da er in beiden vorkommt?
    xDD_k_T_ist = J_x * qDD_k_T + xDD_JDqD; % alle vorbestimmten Terme
    xDD_k_N_ist = J_x * qDD_N_pre;
    phizDD_k_ist = xDD_k_N_ist(end) + xDD_k_T_ist(end);
    % Prüfe, ob Grenze überschritten wird. Erlaube asymmetrische Grenzen.
    % Ziehe den bereits gesetzten Anteil "T" aus der Aufgabe nicht ab.
    % Sonst keine Vorsteuerung der Aufgabenbewegung möglich.
    phizDDmax = s.xDDlim(6,2);
    phizDDmin = s.xDDlim(6,1);
    if phizDD_k_ist > phizDDmax || phizDD_k_ist < phizDDmin
      % Alternative 1: Zusätzlicher Term
      if phizDD_k_ist > phizDDmax
        delta_phizDD = phizDDmax - phizDD_k_ist; % Wert zu groß. muss kleiner werden
      else
        delta_phizDD = phizDDmin - phizDD_k_ist; % Wert zu klein, muss größer werden
      end
      delta_qDD = J_x \ [zeros(5,1); delta_phizDD];
      qDD_N_pre = qDD_N_pre + delta_qDD;
      % Probe: 
      % disp(J_x*qDD_N_pre)
%       % Alternative 2: Runterskalieren (nur, wenn Wert größer Null)
%       % Begrenze die Nullraumkomponente so, dass die Grenze genau erreicht
%       % wird. Dadurch wird auch die Grenze aus s.xDDlim genau erreicht.
%       if phizDD_k_N_ist > phizDDmax
%         scale = phizDDmax / phizDD_k_N_ist;
%       else
%         scale = phizDDmin / phizDD_k_N_ist;
%       end
%       % Skaliere Gelenk-Beschleunigung herunter. Dadurch wird die
%       % Komponente der Nullraumbewegung genauso runterskaliert.
%       qDD_N_pre = scale*qDD_N_pre;
    end
  end
  % Reduziere die Nullraumbeschleunigung im Gelenkraum, falls Grenzen für
  % Geschwindigkeit der redundanten Endeffektor-Koordinaten verletzt werden
  % Betrachtung von 1FG-Aufgabenredundanz mit EE-Drehung
  if NQJ - sum(I_EE) == 1 && ~I_EE(end) && limits_xD_set && enforce_xDlim
    % Aufgrund aktueller Beschleunigung erwartete Geschwindigkeit
    % (Getrennt nach Komponenten)
    qD_pre = qD_k + (qDD_N_pre+qDD_k_T)*dt;
    qD_T_pre = qD_k_T + qDD_k_T*dt;
    qD_N_pre = qD_pre - qD_T_pre;
    % Bestimmung der daraus resultierenden Plattform-Geschwindigkeit
    xD_T_pre = J_x * qD_T_pre;
    xD_N_pre = J_x * qD_N_pre;
    xD_pre= xD_T_pre + xD_N_pre; % = J_x * qD_pre
    % Absolute Grenzen für die EE-Drehung
    phizDlim = s.xDlim(6,:);
    phizDmax = phizDlim(2);
    phizDmin = phizDlim(1);
    % Grenzen für Nullraum-Anteil in der EE-Drehung: 
    phizDmax_N = phizD_N_lim(2); % Bestimmung oben aus Runterskalierung ...
    phizDmin_N = phizD_N_lim(1); % ... bei Rastpunkten
    % Prüfe, ob Grenzen gesamt oder für Nullraumteil verletzt werden
    phizD_pre = xD_pre(end);
    phizD_N_pre = xD_N_pre(end);
    phizDD_counterlim = 0;
    if phizD_pre > phizDmax || phizD_pre < phizDmin % Prüfe absolute Grenzen
      if phizD_pre > phizDmax
        phizDD_counterlim = (phizDmax-phizD_pre)/dt; % Geschw. zu groß -> negative Beschl.
      else
        phizDD_counterlim = (phizDmin-phizD_pre)/dt; % Geschw. zu klein -> positive Beschl.
      end
    elseif phizD_N_pre > phizDmax_N || phizD_N_pre < phizDmin_N% Prüfe Grenzen für Nullraumgeschwindigkeit
      if phizD_N_pre > phizDmax_N
        phizDD_counterlim = (phizDmax_N-phizD_N_pre)/dt; % Geschw. zu groß -> negative Beschl.
      else
        phizDD_counterlim = (phizDmin_N-phizD_N_pre)/dt; % Geschw. zu klein -> positive Beschl.
      end
    end
    if phizDD_counterlim ~= 0
      % Erzeuge die Nullraumbeschleunigung im Gelenkraum
      delta_qDD = J_x \ [zeros(5,1); phizDD_counterlim];
      qDD_N_pre = qDD_N_pre + delta_qDD;
      % Debug: Nach dieser Rechnung diesen Block nochmal ausführen. Es muss
      % genau der Grenzfall herauskommen für phizD_pre bzw. phizD_N_pre
    end
  end
  
  % Berechne maximale Nullraum-Beschleunigung bis zum Erreichen der
  % Geschwindigkeitsgrenzen im Gelenkraum. Reduziere, falls notwendig.
  if redundant && limits_qD_set && enforce_qDlim  % Nullraum-Bewegung erlaubt Begrenzung der Gelenk-Geschwindigkeit
    % Beschleunigung basierend auf Nullraum-Bewegung, [RMG16]/(20)
    qDD_pre = qDD_k_T + qDD_N_pre; % [3]/(1)
    % Daraus berechnete Geschwindigkeit im nächsten Zeitschritt
    qD_pre = qD_k + qDD_pre*dt;
    % Prüfe, ob Grenzen damit absehbar verletzt werden. Grenzen oben
    % dynamisch berechnet.
    qDmax = min(qD_k_T + qD_N_lim(:,2), qDlim(:,2));
    qDmin = max(qD_k_T + qD_N_lim(:,1), qDlim(:,1));
    deltaD_ul = (qDmax - qD_pre); % Überschreitung der Maximalwerte: <0
    deltaD_ll = (-qDmin + qD_pre); % Unterschreitung Minimalwerte: <0
    if any([deltaD_ul;deltaD_ll] < 0)
      if min(deltaD_ul)<min(deltaD_ll)
        % Verletzung nach oben ist die größere
        [~,I_worst] = min(deltaD_ul);
        qDD_lim_I = (qDmax(I_worst)-qD_k(I_worst))/dt;% [3]/(3)
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_worst] = min(deltaD_ll);
        qDD_lim_I = (qDmin(I_worst)-qD_k(I_worst))/dt;
      end
      % Ein Geschwindigkeits-Grenzwert würde im folgenden Schritt
      % verletzt werden. Versuche die Beschleunigung durch
      % Nullraumbewegung zu begrenzen. "Ziehe" die Geschwindigkeit in
      % Richtung der Mitte der Grenzen.
      qD_pre_h = qD_pre;
      % qD_pre_h(~(deltaD_ll<0|deltaD_ul<0)) = 0; % Nur Reduzierung, falls Grenze verletzt
      [~, hdqD] = invkin_optimcrit_limits1(qD_pre_h, [qDmin,qDmax]);
      % Dieser Beschleunigungsvektor liegt im Nullraum der Jacobi-Matrix
      % (erfüllt also noch die Soll-Beschleunigung des Endeffektors).
      % Der Vektor führt zu einer Reduzierung der Geschwindigkeit von den
      % Grenzen weg
      qDD_N_h = N * (-hdqD');
      % Normiere den Vektor auf den am stärksten grenzverletzenden Eintrag
      qDD_N_he = qDD_N_h/qDD_N_h(I_worst); % [3]/(5)
      if ~any(isinf(qDD_N_he)) && ~any(isnan(qDD_N_he))
        % Stelle Nullraumbewegung so ein, dass schlechtester Wert gerade so
        % an der Grenze landet.
        qDD_N_korr_I = -qDD_pre(I_worst) + qDD_lim_I; % [3]/(7)
        % Erzeuge kompletten Vektor als durch Skalierung des Nullraum-Vektors
        qDD_N_korr = qDD_N_korr_I*qDD_N_he; % [3]/(8)
        qDD_N_post = qDD_N_pre+qDD_N_korr; % [3]/(6)
      else
        qDD_N_post = qDD_N_pre;
      end
      if false % debug
        Iutest = qD_k + (qDD_k_T+qDD_N_post)*dt > qDmax + 1e-6;
        Iltest = qD_k + (qDD_k_T+qDD_N_post)*dt < qDmin - 1e-6;
        if min(deltaD_ul)<min(deltaD_ll) && Iutest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Geschwindigkeits-Obergrenze');
        end
        if min(deltaD_ul)>min(deltaD_ll) && Iltest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Geschwindigkeits-Untergrenze');
        end
        if any(Iutest|Iltest)
          warning(['Beim Versuch die Verletzung der Geschw.-Grenze fuer ', ...
            'Gelenk %d zu vermeiden, wurde eine andere Grenze verletzt'], I_worst);
        end
      end
      
      % Die Nullraumbewegung zur Vermeidung der Geschwindigkeitsgrenzen
      % kann fehlschlagen, wenn die fragliche Geschwindigkeitskomponente
      % nicht im Nullraum beeinflussbar ist. Daher nochmals Begrenzung der
      % neuen Beschleunigung im Nullraum. 
      delta_ul_rel = (qDD_N_max - qDD_N_post)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qDD_N_min + qDD_N_post)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qDD_N_max(I_max))/(qDD_N_post(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qDD_N_min(I_min))/(qDD_N_post(I_min));
        end
        qDD_N_post = scale*qDD_N_post;
      end
    else
      % Keine Verletzung der Geschwindigkeitsgrenzen. Lasse
      % Beschleunigung so wie sie ist
      qDD_N_post = qDD_N_pre;
    end
  else
    % Keine Grenzen für qD gesetzt. Beschleunigung muss nicht korrigiert
    % werden
    qDD_N_post = qDD_N_pre;
  end
  
  % Reduziere die Nullraumbeschleunigung im Gelenkraum, falls Grenzen für
  % Position der Plattform-Koordinaten verletzt werden
  if redundant && NQJ - sum(I_EE) == 1 && ~I_EE(end) && limits_x_set && enforce_xlim
    % Berechne Ist-x-Beschleunigung aufgrund aktueller q-Beschleunigung.
    qDD_pre = qDD_k_T + qDD_N_post;
    qD_pre = qDD_pre * dt;
    xDD_k_pre = J_x * qDD_pre + JD_x * qD_pre;
    phizDD_k_pre = xDD_k_pre(6);
    % Bestimme erwartete EE-Drehung (Annahme: Konstante Beschleunigung)
    phiz_pre = x_k_ist(6) + xD_k_ist(6)*dt + 0.5*phizDD_k_pre*dt^2;
    % Prüfe, ob Grenzen damit absehbar verletzt werden. Grenzen sind
    % relativ zur Soll-Trajektorie in x_k (nicht: x_k_ist)
    if phiz_pre < x_k(6) + xlim(6,1)
      delta_phiz = x_k(6) + xlim(6,1) - phiz_pre;
    elseif phiz_pre > x_k(6) + xlim(6,2)
      delta_phiz = x_k(6) + xlim(6,2) - phiz_pre;
    else
      delta_phiz = 0;
    end
    % Erzeuge eine Nullraumbewegung um die überlaufende EE-Drehung
    % auszugleichen
    if delta_phiz ~= 0
      % Ansatz: delta_phiz = 0.5 * phizDD_counterlim * dt^2
      phizDD_counterlim = 2 * (delta_phiz*1.03) / dt^2; % 3% mehr wegen Ungenauigkeit
      xDD_counterlim = [zeros(5,1); phizDD_counterlim];
      delta_qDD = J_x(Rob_I_EE,:) \ xDD_counterlim(Rob_I_EE);
      qDD_N_post = qDD_N_post + delta_qDD;
    end
  end
  
  % Berechne maximale Nullraum-Beschleunigung bis zum Erreichen der
  % Positionsgrenzen. Reduziere, falls notwendig. Berechnung nach Betrachtung
  % der Geschwindigkeits- und Beschl.-Grenzen, da Position wichtiger ist.
  if redundant && limits_q_set && enforce_qlim % Nullraum-Optimierung erlaubt Begrenzung der Gelenk-Position
    qDD_pre2 = qDD_k_T+qDD_N_post;
    % Daraus berechnete Position und Geschwindigkeit im nächsten Zeitschritt
    % Ansatz: Konstante Beschleunigung (für Position die aktuelle Geschw.)
    qD_pre2 = qD_k + qDD_pre2*dt;
    q_pre2 = q_k + qD_k*dt + 0.5*qDD_pre2*dt^2;
    % Prüfe, ob Grenzen damit absehbar verletzt werden
    delta_ul = (qmax - q_pre2); % Überschreitung der Maximalwerte: <0
    delta_ll = (-qmin + q_pre2); % Unterschreitung Minimalwerte: <0
    if any([delta_ul;delta_ll] < 0)
      if min(delta_ul)<min(delta_ll)
        % Verletzung nach oben ist die größere
        [~,I_worst] = min(delta_ul);
        qDD_lim_I = 2/dt^2*(qmax(I_worst)-q_k(I_worst)-qD_pre2(I_worst)*dt);
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_worst] = min(delta_ll);
        qDD_lim_I = 2/dt^2*(qmin(I_worst)-q_k(I_worst)-qD_pre2(I_worst)*dt);
      end
      q_pre_h = q_pre2;
      [~, hdq] = invkin_optimcrit_limits1(q_pre_h, qlim);
      % Dieser Beschleunigungsvektor liegt im Nullraum der Jacobi-Matrix
      % (erfüllt also noch die Soll-Beschleunigung des Endeffektors).
      % Der Vektor führt zu einer Reduzierung der Geschwindigkeit von den
      % Grenzen weg
      qDD_N_h = N * (-hdq');
      % Normiere den Vektor auf den am stärksten grenzverletzenden Eintrag
      qDD_N_he = qDD_N_h/qDD_N_h(I_worst); % [3]/(5)
      % Stelle Nullraumbewegung so ein, dass schlechtester Wert gerade so
      % an der Grenze landet.
      qDD_N_korr_I = -qDD_pre2(I_worst) + qDD_lim_I; % [3]/(7)
      % Erzeuge kompletten Vektor als durch Skalierung des Nullraum-Vektors
      qDD_N_korr = qDD_N_korr_I*qDD_N_he; % [3]/(8)
      qDD_N_post2 = qDD_N_post+qDD_N_korr; % [3]/(6)
      if false % Debug
        Iutest = q_k + qD_k*dt + 0.5*(qDD_k_T+qDD_N_post2)*dt^2 > qmax + 1e-6;
        Iltest = q_k + qD_k*dt + 0.5*(qDD_k_T+qDD_N_post2)*dt^2 < qmin - 1e-6;
        if min(delta_ul)<min(delta_ll) && Iutest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Positions-Obergrenze');
        end
        if min(delta_ul)>min(delta_ll) && Iltest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Positions-Untergrenze');
        end
        if any(Iutest|Iltest)
          warning(['Beim Versuch die Verletzung der Positions-Grenze fuer ', ...
            'Gelenk %d zu vermeiden, wurde eine andere Grenze verletzt'], I_worst);
        end
      end
      % Die Nullraumbewegung zur Vermeidung der Positionsgrenzen
      % kann fehlschlagen, wenn die fragliche Gelenkwinkelkomponente
      % nicht im Nullraum beeinflussbar ist. Daher nochmals Begrenzung der
      % neuen Beschleunigung im Nullraum. 
      delta_ul_rel = (qDD_N_max - qDD_N_post2)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qDD_N_min + qDD_N_post2)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qDD_N_max(I_max))/(qDD_N_post2(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qDD_N_min(I_min))/(qDD_N_post2(I_min));
        end
        qDD_N_post2 = scale*qDD_N_post2;
      end
    else
      % Keine Verletzung der Geschwindigkeitsgrenzen. Lasse
      % Beschleunigung so wie sie ist
      qDD_N_post2 = qDD_N_post;  
    end
  else
    qDD_N_post2 = qDD_N_post;
  end
  % Beschleunigung aus Aufgabe und Nullraumbewegung, [RMG16]/(20)
  qDD_k = qDD_k_T + qDD_N_post2;
  I_wn = [idx_wnP.qlim_par,   idx_wnP.qlim_hyp,   idx_wnP.qDlim_par,...
          idx_wnP.qDlim_hyp,  idx_wnP.ikjac_cond, idx_wnP.jac_cond,...
          idx_wnP.coll_hyp,   idx_wnP.instspc_hyp,idx_wnP.xlim_par,...
          idx_wnP.xlim_hyp,   idx_wnP.xDlim_par,  idx_wnP.coll_par, ...
          idx_wnP.instspc_par,idx_wnP.poserr_ee];
  I_h =  [idx_hn.qlim_par,    idx_hn.qlim_hyp,    idx_hn.qDlim_par,...
          idx_hn.qDlim_hyp,   idx_hn.ikjac_cond,  idx_hn.jac_cond,...
          idx_hn.coll_hyp,    idx_hn.instspc_hyp, idx_hn.xlim_par,...
          idx_hn.xlim_hyp,    idx_hn.xDlim_par,   idx_hn.coll_par, ...
          idx_hn.instspc_par, idx_hn.poserr_ee];
  Stats.h(k,:) = [sum(wn(I_wn).*h(I_h)),h'];
  %% Anfangswerte für Positionsberechnung in nächster Iteration
  % Berechne Geschwindigkeit aus Linearisierung für nächsten Zeitschritt
  % Nehme nur die Nullraum-Komponente. Die Aufgabenkomponente wird in
  % nächster Iteration aus der Trajektorie aktualisiert
  qDNk0 = qD_k + qDD_k*dt - qD_k_T;
  % Aus Geschwindigkeit berechneter neuer Winkel für den nächsten Zeitschritt
  % Taylor-Reihe bis 2. Ordnung für Position (Siehe [2])
  qk0 = q_k + qD_k*dt + 0.5*qDD_k*dt^2;
  if any(isnan(qk0))
    Stats.errorcode = 2;
    break; % aufgrund von Singularität o.ä. unendlich hohe Werte
  end
  %% Ergebnisse speichern
  QD(k,:) = qD_k;
  QDD(k,:) = qDD_k;
  J_x_alt = J_x;
  %% Abbruchbedingung prüfen
  if any(~isnan(s.abort_thresh_h)) && any(h >= s.abort_thresh_h)
    Stats.errorcode = 3;
    break;
  end
  Stats.iter = k;
end
if nargout == 6
  if wn(idx_wnP.coll_hyp) ~= 0 % Berechnung muss genauso sein wie oben
    % Trage den Wert ein, ab dem eine Kollision vorliegt
    Stats.h_coll_thresh = invkin_optimcrit_limits3(0, ...
      [-5*collobjdist_thresh, 0], -collobjdist_thresh);
  end
  if wn(idx_wnP.instspc_hyp) ~= 0
    % Trage den Wert ein, ab dem eine Bauraumverletzung vorliegt
    Stats.h_instspc_thresh = invkin_optimcrit_limits3(0, ...
      [-100.0, 0], -s.installspace_thresh);
  end
end
