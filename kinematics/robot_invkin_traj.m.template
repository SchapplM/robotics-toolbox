% Inverse Kinematik für komplette Trajektorie für
% %RN%
% Allgemeine, stark parametrierbare Funktion zum Aufruf mit allen möglichen
% Einstellungen
% Iterative Lösung der inversen Kinematik mit inverser Jacobi-Matrix
% Zusätzlich Nutzung der differentiellen Kinematik für schnellere Konvergenz
% (Es wird vorausgesetzt und ausgenutzt, dass die EE-Trajektorie stetig ist)
%
% Eingabe:
% X [NT x 6]
%   Trajektorie von EE-Lagen (Sollwerte) für NT Zeitschritte aus T
% XD [NT x 6]
%   Trajektorie von EE-Geschwindigkeiten (Sollwerte)
%   (Die Orientierung wird durch Euler-Winkel-Zeitableitung dargestellt)
% XDD [NT x 6]
%   Trajektorie von EE-Beschleunigungen (Sollwerte)
%   Orientierung bezogen auf Euler-Winkel
% PHI
%   Kinematische Zwangsbedingungen über die Trajektorie
% T [NT x 1]
%   Zeitbasis der Trajektorie (Alle Zeit-Stützstellen)
% q0 [%NQJ% x 1]
%   Anfangs-Gelenkwinkel für Algorithmus
% s
%   Struktur mit Eingabedaten. Felder, siehe Quelltext dieser Funktion und
%   von `%RN%_invkin_eulangresidual` sowie aufrufende Methode aus
%   SerRob-Klasse. Zusätzliche Felder gegenüber invkin-Funktion.
%
% Ausgabe:
% Q [NT x %NQJ%]
%   Trajektorie von Gelenkpositionen (Lösung der IK)
% QD [NT x %NQJ%]
%   Trajektorie von Gelenkgeschwindigkeiten
% QDD [NT x %NQJ%]
%   Trajektorie von Gelenkbeschleunigungen
% PHI
%   Fehlermaß der inversen Kinematik für alle Zeitschritte
% JointPos_all [NT x (%NQJ%*3)]
%   gestapelte Positionen aller Gelenke für alle Zeitschritte
%   (Entspricht letzter Spalte aller homogener Transformationsmatrizen)
% Stats
%   Struktur mit Detail-Ergebnissen für den Verlauf der Berechnung
%
% Siehe auch: ParRob/invkin_traj

% TODO: EE-Trajektorie auch als Winkelgeschwindigkeit und zusätzlicher
%       Schalter für Umrechnung auf analytische Jacobi-Matrix
% TODO: Bei Verletzung von qD ist qD/qDD leicht inkonsistent.

% Quelle:
% [1] Aufzeichnungen Schappler vom 28.11.2018
% [2] Aufzeichnungen Schappler vom 11.12.2018
% [3] Aufzeichnungen Schappler vom 06.07.2020
% [4] Aufzeichnungen Schappler vom 25.03.2020
% [RMG16] Reiter et al.: Inverse Kinematics in Minimum-Time Trajectory
% Planning for Kinematically Redundant Manipulators (2016)
% [RMG18] Reiter et al.: On higher order inverse kinematics methods in 
% time-optimal trajectory planning for kinematically redundant manipulators (2018)


% Generated in SerRobLib from template file in robotics repo
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2019-02
% (C) Institut für Mechatronische Systeme, Leibniz Universität Hannover

function [Q, QD, QDD, PHI, JointPos_all, Stats] = %RN%_invkin_traj(X, XD, XDD, T, q0, s)

%% Coder Information
%#codegen
%$cgargs {coder.newtype('double',[inf,6]),coder.newtype('double',[inf,6]),
%$cgargs  coder.newtype('double',[inf,6]),coder.newtype('double',[inf,1]),
%$cgargs zeros(%NQJ%,1), struct(
%$cgargs            'pkin', zeros(%NKP%,1),
%$cgargs          'sigmaJ', zeros(%NQJ%,1),
%$cgargs            'qlim', zeros(%NQJ%,2),
%$cgargs           'qDlim', zeros(%NQJ%,2),
%$cgargs          'qDDlim', zeros(%NQJ%,2),
%$cgargs            'xlim', zeros(%NQJ%,2),
%$cgargs           'xDlim', zeros(%NQJ%,2),
%$cgargs          'xDDlim', zeros(%NQJ%,2),
%$cgargs            'I_EE', true(1,6),
%$cgargs     'phiconv_W_E', uint8(2),
%$cgargs        'I_EElink', uint8(0),
%$cgargs            'reci', true,
%$cgargs    'simplify_acc', false,
%$cgargs 'optimcrit_limits_hyp_deact', 0.9,
%$cgargs           'T_N_E', zeros(4,4),
%$cgargs               'K', zeros(%NQJ%,1),
%$cgargs              'wn', zeros(12,1),
%$cgargs      'maxrelstep', 0.1,
%$cgargs       'normalize', false,
%$cgargs           'n_min', 0,
%$cgargs           'n_max', 1000,
%$cgargs        'rng_seed', NaN,
%$cgargs        'Phit_tol', 1.0000e-10,
%$cgargs        'Phir_tol', 1.0000e-10)}

%% Initialisierung
% Vorbelegung der Ausgabe
Q = NaN(length(T), %NQJ%);
QD = Q;
QDD = Q;
PHI = NaN( length(T), sum(s.I_EE) );
JointPos_all = NaN( length(T), (%NJ%+1)*3 );

% Einstellungsvariablen aus Struktur herausholen
NQJ = %NQJ%;
I_EE = s.I_EE;
n_Phi_t = sum(s.I_EE(1:3));
nt = length(T);
link_index = s.I_EElink;
pkin = s.pkin;
r_i_i_C = s.T_N_E(1:3,4);
% Prüfe, ob Grenzen für die Position gesetzt wurden
qlim = s.qlim;
qmin = qlim(:,1);
qmax = qlim(:,2);
if all(~isnan(s.qlim(:)))
  limits_q_set = true;
else
  % Grenzen sind nicht wirksam
  qmin(:) = -Inf;
  qmax(:) =  Inf;
  limits_q_set = false;
end
% Prüfe, ob Grenzen für die Geschwindigkeit gesetzt wurden
qDlim = s.qDlim;
qDmin = qDlim(:,1);
qDmax = qDlim(:,2);
if all(~isnan(s.qDlim(:)))
  limits_qD_set = true;
else
  % Grenzen sind nicht wirksam
  qDmin(:) = -Inf;
  qDmax(:) =  Inf;
  limits_qD_set = false;
end
% Prüfe, ob Grenzen für die Beschleunigung gesetzt wurden
qDDlim = s.qDDlim;
qDDmin = qDDlim(:,1);
qDDmax = qDDlim(:,2);
if all(~isnan(s.qDDlim(:)))
  limits_qDD_set = true;
else
  % Grenzen sind nicht wirksam
  qDDmin(:) = -Inf;
  qDDmax(:) =  Inf;
  limits_qDD_set = false;
end
% Schwellwert in Gelenkkoordinaten für Aktivierung des Kriteriums für 
% hyperbolisch gewichteten Abstand von den Grenzen.
qlim_thr_h2 = repmat(mean(qlim,2),1,2) + repmat(qlim(:,2)-qlim(:,1),1,2).*...
  repmat([-0.5, +0.5]*s.optimcrit_limits_hyp_deact,NQJ,1);
% Schwellwert der Z-Rotation (3T2R) für Aktivierung des Kriteriums für 
% hyperbolisch gewichteten Abstand von den Grenzen.
xDlim_thr_h11 = [s.xDlim(:,1) s.xDlim(:,2)]*pi/180*0.8; % vorläufig auf 80% der Grenzen in xDlim
xDDlim_thr_h12 = [s.xDDlim(:,1) s.xDDlim(:,2)]*pi/180*0.8; % vorläufig auf 80% der Grenzen in xDDlim
wn = s.wn;
if any(wn ~= 0)
  nsoptim = true;
else
  % Keine zusätzlichen Optimierungskriterien
  nsoptim = false;
end
% Damit der Roboter einen Nullraum für Nebenoptimierungen hat, muss er min.
% 7FG für 6FG-Aufgaben und 6FG für 5FG-Aufgaben haben.
if sum(I_EE) >= NQJ
  % Es gibt Gelenkgeschwindigkeitsgrenzen, sie können aber nicht genutzt
  % werden, da keine Nullraumbewegung möglich sind.
  limits_qD_set = false;
  % Keine Optimierungen im Nullraum möglich
  nsoptim = false;
end

simplify_acc = s.simplify_acc;
% Einstellungsvariable für Positions-IK zusammenstellen. Fast alle sind
% gleich. Es dürfen aber keine überzähligen Felder übergeben werden.
s_pik = struct( ...
  'pkin', s.pkin, ...
  'sigmaJ', s.sigmaJ, ...
  'qlim', s.qlim, ...
  'xlim', s.xlim, ...
  'I_EE', s.I_EE, ...
  'phiconv_W_E', s.phiconv_W_E, ...
  'I_EElink', s.I_EElink, ...
  'reci', s.reci, ...
  'T_N_E', s.T_N_E, ...
  'K', s.K, ...
  'Kn', zeros(%NQJ%,1), ... % Keine Nullraumoptimierung sinnvoll. ...
  'wn', zeros(5,1), ... % ... Wird in Traj. gemacht.
  'maxstep_ns', 0, ... % keine Bedeutung, da keine Nullraumbewegung möglich
  'scale_lim', 0, ... % Herunterskalieren nicht sinnvoll (da keine NR-Bew.)
  'maxrelstep', s.maxrelstep, ... 
  'finish_in_limits', false, ... % Ohne Nullraumbewegung nicht möglich
  'optimcrit_limits_hyp_deact', NaN, ... % nicht relevant (da keine Nullraumbewegung)
  'normalize', s.normalize, ... 
  'condlimDLS', 1, ... 
  'lambda_min', 2e-4, ... 
  'n_min', s.n_min, ...
  'n_max', s.n_max, ...
  'rng_seed', s.rng_seed, ...
  'Phit_tol', s.Phit_tol, ...
  'Phir_tol', s.Phir_tol, ...
  'retry_on_limitviol', false, ... % nicht sinnvoll
  'retry_limit', 0);

% Gelenkkonfiguration, bei der Nebenbed. 5 (Kondition) das letzte mal
% berechnet wurde
q_wn5 = inf(NQJ,1);
% Gradient von Nebenbedingung 5
h5dq = NaN(1,NQJ);

% Zuweisung notwendig für mex (u.a. k-Schleife wird nicht vollständig erkannt)
qk0 = q0;
qDk0 = zeros(NQJ,1);
qDD_k_T = zeros(NQJ,1);
qD_k = zeros(NQJ,1);
qD_N_pre_alt = zeros(NQJ,1);
qDD_N_pre1 = zeros(NQJ,1);
N = zeros(NQJ,NQJ);
dt = 0;
J_x_alt = zeros(6,NQJ);
Stats = struct('h', NaN(nt,1+9));
h = zeros(9,1);
%% Iterative Berechnung der gesamten Trajektorie
for k = 1:nt
  Tr0E_k = [eul2r(X(k,4:6)', s.phiconv_W_E), X(k,1:3)'];
  if k < nt % Schrittweite für letzten Zeitschritt angenommen wie vorletzter
    dt = T(k+1)-T(k); % Zeit bis zum nächsten Abtastpunkt
  end
  %% Gelenk-Position berechnen
  % Inverse Kinematik für aktuellen Bahnpunkt. Nutze Anfangswert aus der
  % differentiellen Kinematik hiernach von der letzten Iteration (k-1)
  [q_k, Phi_k, Tc_stack_k] = %RN%_invkin_eulangresidual(Tr0E_k, qk0, s_pik);
  % Abspeichern für Ausgabe.
  Q(k,:) = q_k;
  PHI(k,:) = Phi_k;
  JointPos_all(k,:) = Tc_stack_k(:,4);
  % Prüfe Erfolg der IK
  if any(abs(Phi_k(1:n_Phi_t)) > s_pik.Phit_tol) || ...
     any(abs(Phi_k(n_Phi_t+1:end)) > s_pik.Phir_tol) || ...
     any(isnan(Phi_k)) || any(isnan(q_k))
    break; % Die IK kann nicht gelöst werden. Weitere Rechnung ergibt keinen Sinn.
  end
  %% Gelenk-Geschwindigkeit berechnen
  % Geometrische Jacobi-Matrix in analytische Jacobi umrechnen (siehe [1]).
  Jg = %RN%_jacobig_sym_varpar(q_k, link_index, r_i_i_C, pkin);
  Tw = euljac(X(k,4:6)', s.phiconv_W_E); % Euler-Transformationsmatrix
  J_x = [Jg(1:3,:); Tw \ Jg(4:6,:)]; % analytische Jacobi-Matrix
  % Gelenk-Geschwindigkeit mit inverser Jacobi
  if ~(nsoptim || limits_qD_set)
    qD_k = J_x(I_EE,:) \ XD(k,I_EE)';
  else
  % Bestimme Korrekturterm zum Ausgleich des Linearisierungsfehlers aus der
  % letzten Iteration (k-1). Ausgleich der Nullraumbewegung, die aus der
  % Beschleunigung berechnet wird. Siehe [3].
    % EE-Geschw. mit der Gelenk-Geschw. aus dem vorherigen Zeitschritt
    % (k-1) berechnet für diesen Zeitschritt (k). Ein Teil von qDk0 geht in
    % den Nullraum. Daher kann nicht einfach obige Formel genommen werden.
    xD_pre = J_x(I_EE,:)*qDk0;
    % Korrektur-Term der Geschwindigkeit: Die Gelenk-Geschwindigkeit mit
    % Berechnung aus (k-1) führt nicht zur korrekten EE-Geschw. in (k)
    xD_korr = -xD_pre+XD(k,I_EE)'; % dieses Residuum sollte klein bleiben
    % Korrekturwert für Gelenk-Geschw. berechnet mit Pseudo-Inverse (ohne
    % Nullraumoptimierung, da nur Ausgleich für numerische Ungenauigkeit)
    qD_korr = J_x(I_EE,:) \ xD_korr;
    % zu xD passende Gelenk-Geschw. für diesen Zeitschritt (k)
    qD_k = qDk0 + qD_korr;
  end
  %% Gelenk-Beschleunigung berechnen
  if ~simplify_acc
    % Zeitableitung der geometrischen Jacobi-Matrix (siehe [1]).
    JgD = %RN%_jacobigD_sym_varpar(q_k, qD_k, link_index, r_i_i_C, pkin);
    % Zeitableitung der Euler-Transformationsmatrix
    TDw = euljacD(X(k,4:6)', XD(k,4:6)', s.phiconv_W_E);
    % Zeitableitung der inversen Euler-Transformationsmatrix
    TwD_inv = -Tw\TDw/Tw;
    % Zeitableitung der analytischen Jacobi (Rotationsteil "e")
    JeD = Tw\JgD(4:6,:) + TwD_inv *Jg(4:6,:);
    % Zeitableitung analytische Jacobi komplett
    JD_x = [JgD(1:3,:); JeD];
  else
    % Annäherung der Jacobi-Zeitableitung durch den linken Differenzen-
    % quotienten der Jacobi-Matrix. Für ersten Zeitschritt ist der Wert
    % hier grob falsch. Annahme: Geschwindigkeit im ersten Zeitschritt
    % immer Null. Daher kein Einfluss. Funktioniert nur bei Rast-Rast-
    % Trajektorien. dt ist die Zeit zum nächsten Schritt. Annahme:
    % Äquidistant.
    JD_x = (J_x-J_x_alt)/dt;
  end
  % Gelenk-Beschleunigung mit inverser Jacobi (bzw. Pseudo-Inv.) berechnen
  % Siehe z.B. [RMG16]/(19)
  qDD_k_T(:) = J_x(I_EE,:) \ (XDD(k,I_EE)' - JD_x(I_EE,:)*qD_k);
  % Setze die Grenzen für qDD_N basierend auf gegebenen Grenzen für 
  % gesamte Beschleunigung und notwendige Beschleunigung qDD_T
  qDD_N_min = qDDmin - qDD_k_T;
  qDD_N_max = qDDmax - qDD_k_T;
  % Nullraumbewegung auf Beschleunigungsebene berechnen. Siehe [RMG16]
  if nsoptim || limits_qD_set
    % Nullraum-Projektor
    N = (eye(NQJ) - pinv(J_x(I_EE,:))*J_x(I_EE,:));
  end
  if nsoptim % Nullraumbewegung, siehe [RMG16], [RMG18]
    % Positions-bezogene Kriterien werden auf Geschwindigkeitsebene behandelt
    % Geschwindigkeits-bezogene Kennzahlen werden auf Beschleunigungsebene behandelt
    v_qD = zeros(NQJ, 1);
    v_qDD = zeros(NQJ, 1);
    if wn(1) ~= 0 || wn(6) ~= 0 % Quadratischer Abstand von Gelenkgrenzen
      [h(1), h1dq] = invkin_optimcrit_limits1(q_k, qlim);
      v_qD = v_qD - wn(6)*h1dq';
      v_qDD = v_qDD - wn(1)*h1dq';
    end
    if wn(2) ~= 0 || wn(7) ~= 0 % Hyperbolischer Abstand von Gelenkgrenzen
      [h(2), h2dq] = invkin_optimcrit_limits2(q_k, qlim, qlim_thr_h2);
      v_qD = v_qD - wn(7)*h2dq';
      v_qDD = v_qDD - wn(2)*h2dq';
    end
    if wn(3) ~= 0 % Quadratischer Abstand von Gelenkgeschwindigkeitsgrenzen
      % Entspricht Dämpfungsterm DeLucaOriSic1992
      [h(3), h3dq] = invkin_optimcrit_limits1(qD_k, qDlim);
      v_qDD = v_qDD - wn(3)*h3dq';
    end
    if wn(4) ~= 0
      [h(4), h4dq] = invkin_optimcrit_limits2(qD_k, qDlim);
      v_qDD = v_qDD - wn(4)*h4dq';
    end
    if wn(5) ~= 0 || wn(8) ~= 0 % Konditionszahl Jacobi-Matrix (Aufgaben-FG)
      condJ = cond(J_x(I_EE,:));
      h(5) = condJ;
      if NQJ - sum(I_EE) == 1 && ~I_EE(end)
        % Redundanz ist reine Aufgabenredundanz mit Rotationssymmetrie
        % Numerischer Differenzenquotient aus Bewegung in EE-z-Drehung.
        xD_test = [zeros(5,1);1e-6];
        qD_test = J_x\xD_test;
        Jg_test = %RN%_jacobig_sym_varpar(q_k+qD_test, link_index, r_i_i_C, pkin);
        J_x_test = [Jg_test(1:3,:); Tw \ Jg_test(4:6,:)]; % analytische Jacobi-Matrix
        condJ_test = cond(J_x_test(I_EE,:));
        % Gradient bezüglich Redundanz-FG (letzter Euler-Winkel)
        h5drz = (condJ_test-condJ)/1e-6;
        % Umrechung auf Gelenke mit Jacobi-Matrix
        h5dq = h5drz*J_x(end,:);
      else
        % Allgemeiner Fall von Redundanz (nicht nur Drehung um die zE-Achse)
        % Bilde Differenzenquotient in allen Gelenkachsen
        if any(abs(q_k-q_wn5) > 3*pi/180) % seltenere Berechnung (Rechenzeit)
          for kkk = 1:NQJ % Differenzenquotient für jede Gelenkkoordinate
            q_test = q_k; % ausgehend von aktueller Konfiguration
            q_test(kkk) = q_test(kkk) + 1e-6; % minimales Inkrement
            Jg_kkk = %RN%_jacobig_sym_varpar(q_test, link_index, r_i_i_C, pkin);
            J_x_kkk_voll = [Jg_kkk(1:3,:); Tw \ Jg_kkk(4:6,:)]; % analytische Jacobi-Matrix
            condJ_kkk = cond(J_x_kkk_voll(I_EE,:));
            h5dq(kkk) = (condJ_kkk-condJ)/1e-6;
          end
          q_wn5 = q_k;
        end
      end
      v_qD = v_qD - wn(8)*h5dq';
      v_qDD = v_qDD - wn(5)*h5dq';
    end
    if wn(9) ~= 0  % Reservierung für spätere Implementierung der Kollisionsvermeidung
      % leer
    end
    if wn(10) ~= 0  % Reservierung für spätere Implementierung der Kollisionsvermeidung
      % leer
    end
    if wn(11) ~= 0  % Limitierung der redundanten Koordinate bzgl. Position (vorerst nur 3T2R)
      % Kriterium für aktuellen Schritt
      h(8) = invkin_optimcrit_limits2(XD(k,6), [s.xDlim(6,1) s.xDlim(6,2)]*pi/180, xDlim_thr_h11);  % !!!Einheit prüfen!!!
      % Kriterium für Inkrement berechnen
      deltaxD_phiz_3T2R = [zeros(5,1);1e-6];
      deltaqD = JD_x \ deltaxD_phiz_3T2R;  % Anwendung sollte bei Geschw. noch korrekt sein?
      h8_test = invkin_optimcrit_limits2(XD(k,6)+deltaxD_phiz_3T2R, [s.xDlim(6,1) s.xDlim(6,2)]*pi/180, xDlim_thr_h11);  % !!!Einheit prüfen!!!
      h8dq = (h8_test-h(8))./deltaqD';
      v_qD = v_qD - wn(11)*h8dq';
      % ODER?:
      % h8drz = (h8_test-h8)/1e-6;
      % h8dq = h8drz*JD_x(end,:);
      % ODER MIT?:
      % [~, Phi4_x_voll] = Rob.constr4grad_x(xE_1);
      % [~, Phi4_q_voll] = Rob.constr4grad_q(q1);
      % Jinv = -Phi4_q_voll\Phi4_x_voll;
      error('Achtung! wn(11) und xDlim sind aktuell vermutlich noch nicht definiert!');
    end
    if wn(12) ~= 0   % Limitierung der redundanten Koordinate bzgl. Geschwindigkeit (vorerst nur 3T2R)
      % Achtung siehe Robotik-Skript bzgl. Rechnung mit qDD bzw. xDD
    end
    
    % Begrenze die Werte für die Gradienten (können direkt an Grenzen
    % oder Singularitäten extrem werden). Dann Numerik-Fehler und keine
    % saubere Nullraumbewegung mehr möglich.
    if any(abs(v_qD)>1e6),  v_qD  = v_qD* 1e6/max(abs(v_qD));  end
    if any(abs(v_qDD)>1e6), v_qDD = v_qDD*1e6/max(abs(v_qDD)); end
    % Berechne die Nullraumbewegung im Gelenkraum aus den Gradienten
    % Nullraum-Geschwindigkeit; [RMG18], Gl. 11
    qD_N_pre = N * v_qD;
    % Berechne die Nullraum-Beschleunigung durch Zeitableitung. [RMG18], Remark 4.
    % Benutze Differenzenquotient anstatt der analytischen Ableitungen in [RMG18]
    qDD_N_pre1 = N*(qD_N_pre-qD_N_pre_alt)/dt;
    % Speichere den Altwert für den Differenzenquotienten
    qD_N_pre_alt = qD_N_pre;
    % Erster Wert ("pre") für Beschleunigung durch Minimierung der
    % Zielfunktion h. Siehe [RMG16]/(20) (zweiter Term)
    % Hier auch direkte Addition der Nullraumbewegung aus Geschwindigkeit.
    qDD_N_pre = qDD_N_pre1 + N * v_qDD;
  else
    qDD_N_pre = zeros(NQJ,1);
  end
  
  % Reduziere die Nullraumbeschleunigung weiter, falls Beschleunigungs-
  % Grenzen erreicht werden. Sollte eigentlich nur hier gemacht werden,
  % wird aber zur Verbesserung der Robustheit auch zusätzlich noch unten
  % gemacht. Hat unten zur Folge, dass Verletzung von Positions- und
  % Geschwindigkeitsgrenzen nicht mit allen Mitteln verhindert werden
  if nsoptim && limits_qDD_set
    delta_ul_rel = (qDD_N_max - qDD_N_pre)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
    delta_ll_rel = (-qDD_N_min + qDD_N_pre)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
    if any([delta_ul_rel;delta_ll_rel] < 0)
      if min(delta_ul_rel)<min(delta_ll_rel)
        % Verletzung nach oben ist die größere
        [~,I_max] = min(delta_ul_rel);
        scale = (qDD_N_max(I_max))/(qDD_N_pre(I_max));
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_min] = min(delta_ll_rel);
        scale = (qDD_N_min(I_min))/(qDD_N_pre(I_min));
      end
      qDD_N_pre = scale*qDD_N_pre;
      % Reduktion der Beschleunigung auf Altwert für gewünschte Nullraum-
      % geschwindigkeit übertragen. Entspricht Anti-Windup für Integrator
      % Hier keine komplette Trennung zwischen Geschw.- und Besch.-Nullraum.
      % Daher kein komplett sauberes Anti-Windup.
      qD_N_pre_alt = qD_N_pre_alt - (1-scale)*qDD_N_pre1*dt;
    end
  end
  % Berechne maximale Nullraum-Beschleunigung bis zum Erreichen der
  % Geschwindigkeitsgrenzen. Reduziere, falls notwendig
  if nsoptim && limits_qD_set % Nullraum-Optimierung erlaubt Begrenzung der Gelenk-Geschwindigkeit
    % Beschleunigung basierend auf Nullraum-Bewegung, [RMG16]/(20)
    qDD_pre = qDD_k_T + qDD_N_pre; % [3]/(1)
    % Daraus berechnete Geschwindigkeit im nächsten Zeitschritt
    qD_pre = qD_k + qDD_pre*dt;
    % Prüfe, ob Grenzen damit absehbar verletzt werden
    deltaD_ul = (qDmax - qD_pre); % Überschreitung der Maximalwerte: <0
    deltaD_ll = (-qDmin + qD_pre); % Unterschreitung Minimalwerte: <0
    if any([deltaD_ul;deltaD_ll] < 0)
      if min(deltaD_ul)<min(deltaD_ll)
        % Verletzung nach oben ist die größere
        [~,I_worst] = min(deltaD_ul);
        qDD_lim_I = (qDmax(I_worst)-qD_k(I_worst))/dt;% [3]/(3)
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_worst] = min(deltaD_ll);
        qDD_lim_I = (qDmin(I_worst)-qD_k(I_worst))/dt;
      end
      % Ein Geschwindigkeits-Grenzwert würde im folgenden Schritt
      % verletzt werden. Versuche die Beschleunigung durch
      % Nullraumbewegung zu begrenzen. "Ziehe" die Geschwindigkeit in
      % Richtung der Mitte der Grenzen.
      qD_pre_h = qD_pre;
      % qD_pre_h(~(deltaD_ll<0|deltaD_ul<0)) = 0; % Nur Reduzierung, falls Grenze verletzt
      [~, hdqD] = invkin_optimcrit_limits1(qD_pre_h, qDlim);
      % Dieser Beschleunigungsvektor liegt im Nullraum der Jacobi-Matrix
      % (erfüllt also noch die Soll-Beschleunigung des Endeffektors).
      % Der Vektor führt zu einer Reduzierung der Geschwindigkeit von den
      % Grenzen weg
      qDD_N_h = N * (-hdqD');
      % Normiere den Vektor auf den am stärksten grenzverletzenden Eintrag
      qDD_N_he = qDD_N_h/qDD_N_h(I_worst); % [3]/(5)
      % Stelle Nullraumbewegung so ein, dass schlechtester Wert gerade so
      % an der Grenze landet.
      qDD_N_korr_I = -qDD_pre(I_worst) + qDD_lim_I; % [3]/(7)
      % Erzeuge kompletten Vektor als durch Skalierung des Nullraum-Vektors
      qDD_N_korr = qDD_N_korr_I*qDD_N_he; % [3]/(8)
      qDD_N_post = qDD_N_pre+qDD_N_korr; % [3]/(6)
      if false % debug
        Iutest = qD_k + (qDD_k_T+qDD_N_post)*dt > qDmax + 1e-6;
        Iltest = qD_k + (qDD_k_T+qDD_N_post)*dt < qDmin - 1e-6;
        if min(deltaD_ul)<min(deltaD_ll) && Iutest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Geschwindigkeits-Obergrenze');
        end
        if min(deltaD_ul)>min(deltaD_ll) && Iltest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Geschwindigkeits-Untergrenze');
        end
        if any(Iutest|Iltest)
          warning(['Beim Versuch die Verletzung der Geschw.-Grenze fuer ', ...
            'Gelenk %d zu vermeiden, wurde eine andere Grenze verletzt'], I_worst);
        end
      end
      
      % Die Nullraumbewegung zur Vermeidung der Geschwindigkeitsgrenzen
      % kann fehlschlagen, wenn die fragliche Geschwindigkeitskomponente
      % nicht im Nullraum beeinflussbar ist. Daher nochmals Begrenzung der
      % neuen Beschleunigung im Nullraum. 
      delta_ul_rel = (qDD_N_max - qDD_N_post)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qDD_N_min + qDD_N_post)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qDD_N_max(I_max))/(qDD_N_post(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qDD_N_min(I_min))/(qDD_N_post(I_min));
        end
        qDD_N_post = scale*qDD_N_post;
      end
    else
      % Keine Verletzung der Geschwindigkeitsgrenzen. Lasse
      % Beschleunigung so wie sie ist
      qDD_N_post = qDD_N_pre;
    end
  else
    % Keine Grenzen für qD gesetzt. Beschleunigung muss nicht korrigiert
    % werden
    qDD_N_post = qDD_N_pre;
  end
  % Berechne maximale Nullraum-Beschleunigung bis zum Erreichen der
  % Positionsgrenzen. Reduziere, falls notwendig. Berechnung nach Betrachtung
  % der Geschwindigkeits- und Beschl.-Grenzen, da Position wichtiger ist.
  if nsoptim && limits_q_set % Nullraum-Optimierung erlaubt Begrenzung der Gelenk-Position
    qDD_pre2 = qDD_k_T+qDD_N_post;
    % Daraus berechnete Position und Geschwindigkeit im nächsten Zeitschritt
    qD_pre2 = qD_k + qDD_pre2*dt;
    q_pre2 = q_k + qD_pre2*dt + 0.5*qDD_pre2*dt^2;
    % Prüfe, ob Grenzen damit absehbar verletzt werden
    delta_ul = (qmax - q_pre2); % Überschreitung der Maximalwerte: <0
    delta_ll = (-qmin + q_pre2); % Unterschreitung Minimalwerte: <0
    if any([delta_ul;delta_ll] < 0)
      if min(delta_ul)<min(delta_ll)
        % Verletzung nach oben ist die größere
        [~,I_worst] = min(delta_ul);
        qDD_lim_I = 2/dt^2*(qmax(I_worst)-q_k(I_worst)-qD_pre2(I_worst)*dt);
      else
        % Verletzung nach unten ist maßgeblich
        [~,I_worst] = min(delta_ll);
        qDD_lim_I = 2/dt^2*(qmin(I_worst)-q_k(I_worst)-qD_pre2(I_worst)*dt);
      end
      q_pre_h = q_pre2;
      [~, hdq] = invkin_optimcrit_limits1(q_pre_h, qlim);
      % Dieser Beschleunigungsvektor liegt im Nullraum der Jacobi-Matrix
      % (erfüllt also noch die Soll-Beschleunigung des Endeffektors).
      % Der Vektor führt zu einer Reduzierung der Geschwindigkeit von den
      % Grenzen weg
      qDD_N_h = N * (-hdq');
      % Normiere den Vektor auf den am stärksten grenzverletzenden Eintrag
      qDD_N_he = qDD_N_h/qDD_N_h(I_worst); % [3]/(5)
      % Stelle Nullraumbewegung so ein, dass schlechtester Wert gerade so
      % an der Grenze landet.
      qDD_N_korr_I = -qDD_pre2(I_worst) + qDD_lim_I; % [3]/(7)
      % Erzeuge kompletten Vektor als durch Skalierung des Nullraum-Vektors
      qDD_N_korr = qDD_N_korr_I*qDD_N_he; % [3]/(8)
      qDD_N_post2 = qDD_N_post+qDD_N_korr; % [3]/(6)
      if false % Debug
        Iutest = q_k + qD_k*dt + 0.5*(qDD_k_T+qDD_N_post2)*dt^2 > qmax + 1e-6;
        Iltest = q_k + qD_k*dt + 0.5*(qDD_k_T+qDD_N_post2)*dt^2 < qmin - 1e-6;
        if min(delta_ul)<min(delta_ll) && Iutest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Positions-Obergrenze');
        end
        if min(delta_ul)>min(delta_ll) && Iltest(I_worst)
          error('Fehler bei Korrektur der Verletzung der Positions-Untergrenze');
        end
        if any(Iutest|Iltest)
          warning(['Beim Versuch die Verletzung der Positions-Grenze fuer ', ...
            'Gelenk %d zu vermeiden, wurde eine andere Grenze verletzt'], I_worst);
        end
      end
      % Die Nullraumbewegung zur Vermeidung der Positionsgrenzen
      % kann fehlschlagen, wenn die fragliche Gelenkwinkelkomponente
      % nicht im Nullraum beeinflussbar ist. Daher nochmals Begrenzung der
      % neuen Beschleunigung im Nullraum. 
      delta_ul_rel = (qDD_N_max - qDD_N_post2)./(qDD_N_max); % Überschreitung der Maximalwerte: <0
      delta_ll_rel = (-qDD_N_min + qDD_N_post2)./(-qDD_N_min); % Unterschreitung Minimalwerte: <0
      if any([delta_ul_rel;delta_ll_rel] < 0)
        if min(delta_ul_rel)<min(delta_ll_rel)
          % Verletzung nach oben ist die größere
          [~,I_max] = min(delta_ul_rel);
          scale = (qDD_N_max(I_max))/(qDD_N_post2(I_max));
        else
          % Verletzung nach unten ist maßgeblich
          [~,I_min] = min(delta_ll_rel);
          scale = (qDD_N_min(I_min))/(qDD_N_post2(I_min));
        end
        qDD_N_post2 = scale*qDD_N_post2;
      end
    else
      % Keine Verletzung der Geschwindigkeitsgrenzen. Lasse
      % Beschleunigung so wie sie ist
      qDD_N_post2 = qDD_N_post;  
    end
  else
    qDD_N_post2 = qDD_N_post;
  end
  
  % Beschleunigung aus Aufgabe und Nullraumbewegung, [RMG16]/(20)
  qDD_k = qDD_k_T + qDD_N_post2;
  Stats.h(k,:) = [sum(wn(1:9).*h(1:9)),h(1:9)'];
  %% Anfangswerte für Positionsberechnung in nächster Iteration
  % Berechne Geschwindigkeit aus Linearisierung für nächsten Zeitschritt
  qDk0 = qD_k + qDD_k*dt;
  % Aus Geschwindigkeit berechneter neuer Winkel für den nächsten Zeitschritt
  % Taylor-Reihe bis 2. Ordnung für Position (Siehe [2])
  qk0 = q_k + qD_k*dt + 0.5*qDD_k*dt^2;
  if any(isnan(qk0))
    break; % aufgrund von Singularität o.ä. unendlich hohe Werte
  end
  %% Ergebnisse speichern
  QD(k,:) = qD_k;
  QDD(k,:) = qDD_k;
  J_x_alt = J_x;
end
