% Ableitung der Rotationskomponente der kinematischen ZB nach der EE-Orientierung
% 
% Variante 3:
% * Absolute Rotation (Basis->PKM-EE)ausgedrückt in XYZ-Euler-Winkeln
% * Rotationsfehler (Basis-PKM-EE) ausgedrückt in ZYX-Euler-Winkeln
% 
% Implementierung mit Einzelmatrizen (nicht mit Endergebnis aus Maple)
% 
% Eingabe:
% q [Nx1]
%   Alle Gelenkwinkel aller serieller Beinketten der PKM
% xE [6x1]
%   Endeffektorpose des Roboters bezüglich des Basis-KS
% 
% Ausgabe:
% Phipphi_red
%   Reduzierte Zeilen: Die Reduktion folgt aus der Klassenvariablen I_EE
% Phipphi [3xN]
%   Ableitung der kinematischen Zwangsbedingungen nach der EE-Orientierung
%   Rotatorischer Teil
%
% Diese Datei ist identisch mit: ParRob/constr3grad_rr.m
% Generierung einer kompilierbaren Matlab-Funktion aus Vorlage.

% Quellen:
% % [2_SchapplerTapOrt2019a] Schappler, M. et al.: Modeling Parallel Robot
% Kinematics for 3T2R and 3T3R Tasks using Reciprocal Sets of Euler Angles
% (Arbeitstitel), Submitted to MDPI Robotics KaRD2, Version of 27.06.2019
% [A] Aufzeichnungen Schappler vom 27.07.2018
% [B] Aufzeichnungen Schappler vom 21.06.2018
% [C] Aufzeichnungen Schappler vom 13.07.2018
% [D] Aufzeichnungen Schappler vom 03.02.2019
% 
% Siehe auch: constr2grad_rr.m (für Führungskette identisch)

% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2018-10
% (C) Institut für Mechatronische Systeme, Universität Hannover

function [Phipphi_red, Phipphi] = %PN%_constr3grad_rr(q, xE, s)

%% Coder Information
%#codegen
%$cgargs {zeros(%NJ%,1),zeros(6,1), struct(
%$cgargs     'phi_P_B_all', zeros(3,%NLEG%),
%$cgargs           'T_P_E', zeros(4,4),
%$cgargs     'phiconv_W_E', uint8(2),
%$cgargs    'Leg_pkin_gen', zeros(%NLEG%,%NKP%),
%$cgargs   'Leg_T_N_E_vec', zeros(6,%NLEG%),
%$cgargs   'Leg_T_0_W_vec', zeros(6,%NLEG%),
%$cgargs   'Leg_I_EE_Task', true(%NLEG%,6),
%$cgargs     'Leg_phi_W_0', zeros(3,%NLEG%),
%$cgargs 'Leg_phiconv_W_0', uint8(zeros(%NLEG%,1)))}

%% Initialisierung
NLEG = %NLEG%;
I_EE = %I_EE%;
I1J_LEG = %I1J_LEG%;
I2J_LEG = %I2J_LEG%;
Leg_I_EElink = %Leg_I_EElink%;

%% Initialisierung mit Fallunterscheidung für symbolische Eingabe
% Endergebnis: [2_SchapplerTapOrt2019a]/(36, 37); Gl. (C.35)

% Initialisierung mit Fallunterscheidung für symbolische Eingabe

Phipphi = zeros(3*NLEG,3);
Phipphi_red = zeros( sum(I_EE(4:6))*NLEG, sum(I_EE(4:6)) );


%% Berechnung
R_P_E = s.T_P_E(1:3,1:3);
R_0_E_x = eul2r(xE(4:6), s.phiconv_W_E);
[~,phiconv_W_E_reci] = euler_angle_properties(s.phiconv_W_E);

for iLeg = 1 % nur Führungskette hat Einfluss (siehe Gl. D.47), [2_SchapplerTapOrt2019a]/(37)
  IJ_i = I1J_LEG(iLeg):I2J_LEG(iLeg);
  qs = q(IJ_i); % Gelenkwinkel dieser Kette
  
  phi_0_Ai = s.Leg_phi_W_0(:,iLeg);
  R_0_0i = eul2r(phi_0_Ai, s.Leg_phiconv_W_0(iLeg));
  R_P_Bi = eulxyz2r(s.phi_P_B_all(:,iLeg));
  R_Bi_P = R_P_Bi.';
  
  % Definitionen, Laden der Kinematik
  Tc_0 = %SN%_fkine_fixb_rotmat_mdh_sym_varpar(qs, s.Leg_pkin_gen(iLeg,:)');
  Leg_T_N_E = [eulxyz2r(s.Leg_T_N_E_vec(1:3,iLeg)),s.Leg_T_N_E_vec(4:6,iLeg);[0 0 0 1]];
  T_0i_Bi = Tc_0(:,:,Leg_I_EElink(iLeg)+1)*Leg_T_N_E;
  R_0i_E_q = T_0i_Bi(1:3,1:3) * R_Bi_P * R_P_E;
  R_0_E_q = R_0_0i * R_0i_E_q;

  % Rotationsmatrix Differenz-Rotation. So Definiert wie in den
  % Zwangsbedingungen bsp6uPs_ZB_phi
  R_Ex_Eq = R_0_E_x' * R_0_E_q; % Argument in [2_SchapplerTapOrt2019a]/(19)

  %% (III) Ableitung des Matrixproduktes
  % Dritter Term in [2_SchapplerTapOrt2019a]/(36) bzw. Gl. (A.50): 
  % [2_SchapplerTapOrt2019a]/(A23); Gl. (B.12)
  % Unabhängig vom Roboter (Rotationsmatrix aus Kinematik wird in
  % Platzhalterelemente eingesetzt)
  % Aus rmatvecprod_diff_rmatvec1_matlab.m
  a11=R_0_E_q(1,1);a21=R_0_E_q(1,2);a31=R_0_E_q(1,3);
  a12=R_0_E_q(2,1);a22=R_0_E_q(2,2);a32=R_0_E_q(2,3);
  a13=R_0_E_q(3,1);a23=R_0_E_q(3,2);a33=R_0_E_q(3,3);
  dPidR2b = [a11 a12 a13 0 0 0 0 0 0; a21 a22 a23 0 0 0 0 0 0; a31 a32 a33 0 0 0 0 0 0; 0 0 0 a11 a12 a13 0 0 0; 0 0 0 a21 a22 a23 0 0 0; 0 0 0 a31 a32 a33 0 0 0; 0 0 0 0 0 0 a11 a12 a13; 0 0 0 0 0 0 a21 a22 a23; 0 0 0 0 0 0 a31 a32 a33;];

  %% (IV) Ableitung von R_0_E nach den Euler-Winkeln
  % Vierter Term in [2_SchapplerTapOrt2019a]/(36) bzw. Gl. (A.50)
  % (XYZ-Euler-Winkel der Endeffektor-Orientierung)
  % Unabhängig vom Roboter (nur von Orientierungsdarstellung)
  dR0Ebdphi = rotmat_diff_eul(xE(4:6), s.phiconv_W_E);
  
  %% (II) Transpositions-Matrix;
  % Gl (C.29), [2_SchapplerTapOrt2019a]/(A19)
  % zweiter Term in [2_SchapplerTapOrt2019a]/(36) bzw. (A.50)
  % Aus permat_rvec_transpose_matlab.m
  P_T = [1 0 0 0 0 0 0 0 0; 0 0 0 1 0 0 0 0 0; 0 0 0 0 0 0 1 0 0; 0 1 0 0 0 0 0 0 0; 0 0 0 0 1 0 0 0 0; 0 0 0 0 0 0 0 1 0; 0 0 1 0 0 0 0 0 0; 0 0 0 0 0 1 0 0 0; 0 0 0 0 0 0 0 0 1;];
  
  %% (I) Ableitung der Euler-Winkel nach der Rotationsmatrix
  % Erster Term in Gl. (A.50): 
  % (ZYX-Euler-Winkel des Orientierungsfehlers)
  % Aus eulzyx_diff_rmatvec_matlab.m
  % Unabhängig vom Roboter (nur von Orientierungsdarstellung) 
  dphidRb = eul_diff_rotmat(R_Ex_Eq, phiconv_W_E_reci);
  
  %% Gesamtergebnis
  % [2_SchapplerTapOrt2019a]/(36) bzw. Gl. (A.50)
  % Gl. (A.50)
  Phi_phi_i_Gradx = dphidRb * P_T*dPidR2b * dR0Ebdphi;
  
  %% Einsetzen in Ausgabevariable
  J1 = 1+3*(iLeg-1);
  J2 = J1+2;
  Phipphi(J1:J2,:) = Phi_phi_i_Gradx;
  
  % Ausgabe mit reduzierter Dimension
  % TODO: Die Auswahl der ZB muss an die jeweilige Aufgabe angepasst
  % werden (3T1R, 3T3R); wegen der Reziprozität EE-FG / Residuum
  K1 = 1; % nur eine Beinkette betrachtet.
  if all(s.Leg_I_EE_Task(iLeg,:) == logical([1 1 1 1 1 0]))
    K2 = 2;
    Phipphi_red( K1:K2, 1:sum(I_EE(4:6)) ) = Phi_phi_i_Gradx([2 3],I_EE(4:6));
  else
    K2 = sum(I_EE(4:6));
    Phipphi_red( K1:K2, 1:sum(I_EE(4:6)) ) = Phi_phi_i_Gradx(I_EE(4:6),I_EE(4:6)); % das war vor anpassung
  end
end
